-- Generated by: $Id: EModelCopyGenerator.atl 4674 2006-06-06 09:45:37Z dwagelaa $
--
-- Double rules were generated for EAnnotation and EStringToMapEntry because
-- Ecore meta-model is implicitly included, even if already loaded via UML2
-- meta-model. These double rules were removed manually.
module UML2Copy;

create OUT : UML2 from IN : UML2;

rule DurationObservationAction {
    from s : UML2!DurationObservationAction
    to t : UML2!DurationObservationAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        duration <- s.duration,
        redefinedElement <- s.redefinedElement,
        value <- s.value,
        structuralFeature <- s.structuralFeature,
        object <- s.object,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ExtensionPoint {
    from s : UML2!ExtensionPoint
    to t : UML2!ExtensionPoint mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule LiteralString {
    from s : UML2!LiteralString
    to t : UML2!LiteralString mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        value <- s.value,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Clause {
    from s : UML2!Clause
    to t : UML2!Clause mapsTo s (
        eAnnotations <- s.eAnnotations,
        bodyOutput <- s.bodyOutput,
        body <- s.body,
        test <- s.test,
        ownedComment <- s.ownedComment,
        decider <- s.decider)
}

rule CreateObjectAction {
    from s : UML2!CreateObjectAction
    to t : UML2!CreateObjectAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        result <- s.result,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        classifier <- s.classifier,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule AcceptEventAction {
    from s : UML2!AcceptEventAction (s.oclIsTypeOf(UML2!AcceptEventAction))
    to t : UML2!AcceptEventAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        trigger <- s.trigger,
        localPostcondition <- s.localPostcondition,
        result <- s.result,
        redefinedElement <- s.redefinedElement,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule LiteralNull {
    from s : UML2!LiteralNull
    to t : UML2!LiteralNull mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ReadSelfAction {
    from s : UML2!ReadSelfAction
    to t : UML2!ReadSelfAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        result <- s.result,
        nameExpression <- s.nameExpression)
}

rule Message {
    from s : UML2!Message
    to t : UML2!Message mapsTo s (
        messageSort <- s.messageSort,
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        signature <- s.signature,
        argument <- s.argument,
        connector <- s.connector,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ReadVariableAction {
    from s : UML2!ReadVariableAction
    to t : UML2!ReadVariableAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        result <- s.result,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        variable <- s.variable,
        redefinedElement <- s.redefinedElement,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Signal {
    from s : UML2!Signal
    to t : UML2!Signal mapsTo s (
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        ownedAttribute <- s.ownedAttribute,
        generalization <- s.generalization,
        substitution <- s.substitution,
        occurrence <- s.occurrence,
        ownedRule <- s.ownedRule,
        redefinedClassifier <- s.redefinedClassifier,
        elementImport <- s.elementImport,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        representation <- s.representation,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule FlowFinalNode {
    from s : UML2!FlowFinalNode
    to t : UML2!FlowFinalNode mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        redefinedElement <- s.redefinedElement,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Realization {
    from s : UML2!Realization (s.oclIsTypeOf(UML2!Realization))
    to t : UML2!Realization mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        supplier <- s.supplier,
        realizingClassifier <- s.realizingClassifier,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        mapping <- s.mapping,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule InformationItem {
    from s : UML2!InformationItem
    to t : UML2!InformationItem mapsTo s (
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        substitution <- s.substitution,
        occurrence <- s.occurrence,
        represented <- s.represented,
        ownedRule <- s.ownedRule,
        redefinedClassifier <- s.redefinedClassifier,
        elementImport <- s.elementImport,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        representation <- s.representation,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule ActivityParameterNode {
    from s : UML2!ActivityParameterNode
    to t : UML2!ActivityParameterNode mapsTo s (
        ordering <- s.ordering,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        upperBound <- s.upperBound,
        selection <- s.selection,
        parameter <- s.parameter,
        redefinedElement <- s.redefinedElement,
        inState <- s.inState,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule TimeInterval {
    from s : UML2!TimeInterval
    to t : UML2!TimeInterval mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        min <- s.min,
        max <- s.max,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Include {
    from s : UML2!Include
    to t : UML2!Include mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        addition <- s.addition,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule PrimitiveFunction {
    from s : UML2!PrimitiveFunction
    to t : UML2!PrimitiveFunction mapsTo s (
        language <- s.language,
        body <- s.body,
        visibility <- s.visibility,
        name <- s.name,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ClearAssociationAction {
    from s : UML2!ClearAssociationAction
    to t : UML2!ClearAssociationAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        object <- s.object,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        association <- s.association,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule State {
    from s : UML2!State (s.oclIsTypeOf(UML2!State))
    to t : UML2!State mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        redefinedState <- s.redefinedState,
        entry <- s.entry,
        stateInvariant <- s.stateInvariant,
        templateBinding <- s.templateBinding,
        exit <- s.exit,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        region <- s.region,
        doActivity <- s.doActivity,
        submachine <- s.submachine,
        deferrableTrigger <- s.deferrableTrigger,
        ownedRule <- s.ownedRule,
        elementImport <- s.elementImport,
        connection <- s.connection,
        ownedComment <- s.ownedComment,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule Lifeline {
    from s : UML2!Lifeline
    to t : UML2!Lifeline mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        decomposedAs <- s.decomposedAs,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        selector <- s.selector,
        represents <- s.represents,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule DestroyLinkAction {
    from s : UML2!DestroyLinkAction
    to t : UML2!DestroyLinkAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        endData <- s.endData,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ProtocolConformance {
    from s : UML2!ProtocolConformance
    to t : UML2!ProtocolConformance mapsTo s (
        eAnnotations <- s.eAnnotations,
        generalMachine <- s.generalMachine,
        ownedComment <- s.ownedComment)
}

rule LiteralInteger {
    from s : UML2!LiteralInteger
    to t : UML2!LiteralInteger mapsTo s (
        value <- s.value,
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ClearStructuralFeatureAction {
    from s : UML2!ClearStructuralFeatureAction
    to t : UML2!ClearStructuralFeatureAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        structuralFeature <- s.structuralFeature,
        object <- s.object,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule RedefinableTemplateSignature {
    from s : UML2!RedefinableTemplateSignature
    to t : UML2!RedefinableTemplateSignature mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        parameter <- s.parameter,
        ownedParameter <- s.ownedParameter,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Dependency {
    from s : UML2!Dependency (s.oclIsTypeOf(UML2!Dependency))
    to t : UML2!Dependency mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        supplier <- s.supplier,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule CollaborationOccurrence {
    from s : UML2!CollaborationOccurrence
    to t : UML2!CollaborationOccurrence mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        roleBinding <- s.roleBinding,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule TimeObservationAction {
    from s : UML2!TimeObservationAction
    to t : UML2!TimeObservationAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        now <- s.now,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        value <- s.value,
        structuralFeature <- s.structuralFeature,
        object <- s.object,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule OutputPin {
    from s : UML2!OutputPin
    to t : UML2!OutputPin mapsTo s (
        ordering <- s.ordering,
        isOrdered <- s.isOrdered,
        visibility <- s.visibility,
        isUnique <- s.isUnique,
        name <- s.name,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        upperValue <- s.upperValue,
        upperBound <- s.upperBound,
        selection <- s.selection,
        redefinedElement <- s.redefinedElement,
        inState <- s.inState,
        lowerValue <- s.lowerValue,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule CallTrigger {
    from s : UML2!CallTrigger
    to t : UML2!CallTrigger mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        operation <- s.operation,
        port <- s.port,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Substitution {
    from s : UML2!Substitution
    to t : UML2!Substitution mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        supplier <- s.supplier,
        realizingClassifier <- s.realizingClassifier,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        contract <- s.contract,
        mapping <- s.mapping,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule GeneralOrdering {
    from s : UML2!GeneralOrdering
    to t : UML2!GeneralOrdering mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule TemplateBinding {
    from s : UML2!TemplateBinding
    to t : UML2!TemplateBinding mapsTo s (
        eAnnotations <- s.eAnnotations,
        signature <- s.signature,
        parameterSubstitution <- s.parameterSubstitution,
        ownedComment <- s.ownedComment)
}

rule ReadLinkObjectEndQualifierAction {
    from s : UML2!ReadLinkObjectEndQualifierAction
    to t : UML2!ReadLinkObjectEndQualifierAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        result <- s.result,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        qualifier <- s.qualifier,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        object <- s.object,
        nameExpression <- s.nameExpression)
}

rule RemoveVariableValueAction {
    from s : UML2!RemoveVariableValueAction
    to t : UML2!RemoveVariableValueAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        variable <- s.variable,
        redefinedElement <- s.redefinedElement,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        value <- s.value,
        nameExpression <- s.nameExpression)
}

rule InformationFlow {
    from s : UML2!InformationFlow
    to t : UML2!InformationFlow mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        conveyed <- s.conveyed,
        realization <- s.realization,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule OpaqueExpression {
    from s : UML2!OpaqueExpression (s.oclIsTypeOf(UML2!OpaqueExpression))
    to t : UML2!OpaqueExpression mapsTo s (
        language <- s.language,
        visibility <- s.visibility,
        body <- s.body,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        behavior <- s.behavior,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ExecutionEnvironment {
    from s : UML2!ExecutionEnvironment
    to t : UML2!ExecutionEnvironment mapsTo s (
        isActive <- s.isActive,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTrigger <- s.ownedTrigger,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        nestedClassifier <- s.nestedClassifier,
        ownedPort <- s.ownedPort,
        ownedStateMachine <- s.ownedStateMachine,
        implementation <- s.implementation,
        generalization <- s.generalization,
        substitution <- s.substitution,
        ownedBehavior <- s.ownedBehavior,
        occurrence <- s.occurrence,
        ownedOperation <- s.ownedOperation,
        nestedNode <- s.nestedNode,
        deployment <- s.deployment,
        ownedRule <- s.ownedRule,
        redefinedClassifier <- s.redefinedClassifier,
        ownedConnector <- s.ownedConnector,
        elementImport <- s.elementImport,
        ownedReception <- s.ownedReception,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        ownedAttribute <- s.ownedAttribute,
        representation <- s.representation,
        classifierBehavior <- s.classifierBehavior,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule Interaction {
    from s : UML2!Interaction
    to t : UML2!Interaction mapsTo s (
        isActive <- s.isActive,
        isAbstract <- s.isAbstract,
        isReentrant <- s.isReentrant,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        formalGate <- s.formalGate,
        ownedTrigger <- s.ownedTrigger,
        lifeline <- s.lifeline,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        nestedClassifier <- s.nestedClassifier,
        ownedPort <- s.ownedPort,
        ownedStateMachine <- s.ownedStateMachine,
        implementation <- s.implementation,
        generalOrdering <- s.generalOrdering,
        generalization <- s.generalization,
        substitution <- s.substitution,
        ownedBehavior <- s.ownedBehavior,
        occurrence <- s.occurrence,
        ownedOperation <- s.ownedOperation,
        ownedRule <- s.ownedRule,
        ownedParameterSet <- s.ownedParameterSet,
        precondition <- s.precondition,
        redefinedClassifier <- s.redefinedClassifier,
        ownedConnector <- s.ownedConnector,
        elementImport <- s.elementImport,
        fragment <- s.fragment,
        redefinedBehavior <- s.redefinedBehavior,
        message <- s.message,
        ownedReception <- s.ownedReception,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        ownedAttribute <- s.ownedAttribute,
        representation <- s.representation,
        postcondition <- s.postcondition,
        parameter <- s.parameter,
        classifierBehavior <- s.classifierBehavior,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule ConnectorEnd {
    from s : UML2!ConnectorEnd
    to t : UML2!ConnectorEnd mapsTo s (
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        eAnnotations <- s.eAnnotations,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        ownedComment <- s.ownedComment,
        partWithPort <- s.partWithPort)
}

rule ApplyFunctionAction {
    from s : UML2!ApplyFunctionAction
    to t : UML2!ApplyFunctionAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        function <- s.function,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        result <- s.result,
        argument <- s.argument,
        redefinedElement <- s.redefinedElement,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule LiteralBoolean {
    from s : UML2!LiteralBoolean
    to t : UML2!LiteralBoolean mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        value <- s.value,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule PackageMerge {
    from s : UML2!PackageMerge
    to t : UML2!PackageMerge mapsTo s (
        eAnnotations <- s.eAnnotations,
        mergedPackage <- s.mergedPackage,
        ownedComment <- s.ownedComment)
}

rule AddVariableValueAction {
    from s : UML2!AddVariableValueAction
    to t : UML2!AddVariableValueAction mapsTo s (
        isReplaceAll <- s.isReplaceAll,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        variable <- s.variable,
        redefinedElement <- s.redefinedElement,
        insertAt <- s.insertAt,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        value <- s.value,
        nameExpression <- s.nameExpression)
}

rule DurationConstraint {
    from s : UML2!DurationConstraint
    to t : UML2!DurationConstraint mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        constrainedElement <- s.constrainedElement,
        specification <- s.specification,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ObjectFlow {
    from s : UML2!ObjectFlow
    to t : UML2!ObjectFlow mapsTo s (
        isMultireceive <- s.isMultireceive,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        isMulticast <- s.isMulticast,
        weight <- s.weight,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        selection <- s.selection,
        redefinedElement <- s.redefinedElement,
        guard <- s.guard,
        transformation <- s.transformation,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Interval {
    from s : UML2!Interval (s.oclIsTypeOf(UML2!Interval))
    to t : UML2!Interval mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        min <- s.min,
        max <- s.max,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ActivityPartition {
    from s : UML2!ActivityPartition
    to t : UML2!ActivityPartition mapsTo s (
        visibility <- s.visibility,
        isDimension <- s.isDimension,
        name <- s.name,
        isExternal <- s.isExternal,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        subgroup <- s.subgroup,
        represents <- s.represents,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule AnyTrigger {
    from s : UML2!AnyTrigger
    to t : UML2!AnyTrigger mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        port <- s.port,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ReplyAction {
    from s : UML2!ReplyAction
    to t : UML2!ReplyAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        returnInformation <- s.returnInformation,
        replyValue <- s.replyValue,
        replyToCall <- s.replyToCall,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Reception {
    from s : UML2!Reception
    to t : UML2!Reception mapsTo s (
        isStatic <- s.isStatic,
        concurrency <- s.concurrency,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        returnResult <- s.returnResult,
        raisedException <- s.raisedException,
        ownedRule <- s.ownedRule,
        elementImport <- s.elementImport,
        ownedComment <- s.ownedComment,
        formalParameter <- s.formalParameter,
        signal <- s.signal,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule Constraint {
    from s : UML2!Constraint (s.oclIsTypeOf(UML2!Constraint))
    to t : UML2!Constraint mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        constrainedElement <- s.constrainedElement,
        specification <- s.specification,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Deployment {
    from s : UML2!Deployment
    to t : UML2!Deployment mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        supplier <- s.supplier,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        configuration <- s.configuration,
        ownedComment <- s.ownedComment,
        deployedArtifact <- s.deployedArtifact,
        nameExpression <- s.nameExpression)
}

rule Model {
    from s : UML2!Model
    to t : UML2!Model mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        viewpoint <- s.viewpoint,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        ownedMember <- s.ownedMember,
        appliedProfile <- s.appliedProfile,
        packageExtension <- s.packageExtension,
        ownedRule <- s.ownedRule,
        packageMerge <- s.packageMerge,
        elementImport <- s.elementImport,
        ownedComment <- s.ownedComment,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule Operation {
    from s : UML2!Operation
    to t : UML2!Operation mapsTo s (
        isQuery <- s.isQuery,
        isStatic <- s.isStatic,
        concurrency <- s.concurrency,
        isOrdered <- s.isOrdered,
        visibility <- s.visibility,
        isUnique <- s.isUnique,
        name <- s.name,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        upperValue <- s.upperValue,
        ownedParameter <- s.ownedParameter,
        returnResult <- s.returnResult,
        raisedException <- s.raisedException,
        bodyCondition <- s.bodyCondition,
        ownedRule <- s.ownedRule,
        elementImport <- s.elementImport,
        lowerValue <- s.lowerValue,
        type <- s.type,
        ownedComment <- s.ownedComment,
        formalParameter <- s.formalParameter,
        redefinedOperation <- s.redefinedOperation,
        postcondition <- s.postcondition,
        precondition <- s.precondition,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule DataStoreNode {
    from s : UML2!DataStoreNode
    to t : UML2!DataStoreNode mapsTo s (
        ordering <- s.ordering,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        upperBound <- s.upperBound,
        selection <- s.selection,
        redefinedElement <- s.redefinedElement,
        inState <- s.inState,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Slot {
    from s : UML2!Slot
    to t : UML2!Slot mapsTo s (
        eAnnotations <- s.eAnnotations,
        definingFeature <- s.definingFeature,
        value <- s.value,
        ownedComment <- s.ownedComment)
}

rule Continuation {
    from s : UML2!Continuation
    to t : UML2!Continuation mapsTo s (
        setting <- s.setting,
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalOrdering <- s.generalOrdering,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule CallBehaviorAction {
    from s : UML2!CallBehaviorAction
    to t : UML2!CallBehaviorAction mapsTo s (
        isSynchronous <- s.isSynchronous,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        result <- s.result,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        onPort <- s.onPort,
        behavior <- s.behavior,
        argument <- s.argument,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule CombinedFragment {
    from s : UML2!CombinedFragment
    to t : UML2!CombinedFragment mapsTo s (
        interactionOperator <- s.interactionOperator,
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalOrdering <- s.generalOrdering,
        cfragmentGate <- s.cfragmentGate,
        operand <- s.operand,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Artifact {
    from s : UML2!Artifact (s.oclIsTypeOf(UML2!Artifact))
    to t : UML2!Artifact mapsTo s (
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        fileName <- s.fileName,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        ownedOperation <- s.ownedOperation,
        generalization <- s.generalization,
        substitution <- s.substitution,
        occurrence <- s.occurrence,
        ownedRule <- s.ownedRule,
        redefinedClassifier <- s.redefinedClassifier,
        ownedAttribute <- s.ownedAttribute,
        elementImport <- s.elementImport,
        manifestation <- s.manifestation,
        nestedArtifact <- s.nestedArtifact,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        representation <- s.representation,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule BroadcastSignalAction {
    from s : UML2!BroadcastSignalAction
    to t : UML2!BroadcastSignalAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        onPort <- s.onPort,
        signal <- s.signal,
        argument <- s.argument,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule PartDecomposition {
    from s : UML2!PartDecomposition
    to t : UML2!PartDecomposition mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        refersTo <- s.refersTo,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        argument <- s.argument,
        generalOrdering <- s.generalOrdering,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression,
        actualGate <- s.actualGate)
}

rule CentralBufferNode {
    from s : UML2!CentralBufferNode (s.oclIsTypeOf(UML2!CentralBufferNode))
    to t : UML2!CentralBufferNode mapsTo s (
        ordering <- s.ordering,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        upperBound <- s.upperBound,
        selection <- s.selection,
        redefinedElement <- s.redefinedElement,
        inState <- s.inState,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule SignalTrigger {
    from s : UML2!SignalTrigger
    to t : UML2!SignalTrigger mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        port <- s.port,
        signal <- s.signal,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Extension {
    from s : UML2!Extension
    to t : UML2!Extension mapsTo s (
        isDerived <- s.isDerived,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        substitution <- s.substitution,
        occurrence <- s.occurrence,
        ownedRule <- s.ownedRule,
        redefinedClassifier <- s.redefinedClassifier,
        elementImport <- s.elementImport,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        representation <- s.representation,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression,
        ownedEnd <- s.ownedEnd)
}

rule LoopNode {
    from s : UML2!LoopNode
    to t : UML2!LoopNode mapsTo s (
        isTestedFirst <- s.isTestedFirst,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        mustIsolate <- s.mustIsolate,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        setupPart <- s.setupPart,
        templateBinding <- s.templateBinding,
        containedNode <- s.containedNode,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        bodyOutput <- s.bodyOutput,
        result <- s.result,
        localPostcondition <- s.localPostcondition,
        bodyPart <- s.bodyPart,
        redefinedElement <- s.redefinedElement,
        ownedRule <- s.ownedRule,
        loopVariableInput <- s.loopVariableInput,
        containedEdge <- s.containedEdge,
        elementImport <- s.elementImport,
        test <- s.test,
        loopVariable <- s.loopVariable,
        decider <- s.decider,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        packageImport <- s.packageImport,
        variable <- s.variable,
        nameExpression <- s.nameExpression)
}

rule TimeTrigger {
    from s : UML2!TimeTrigger
    to t : UML2!TimeTrigger mapsTo s (
        isRelative <- s.isRelative,
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        when <- s.when,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        port <- s.port,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule SendSignalAction {
    from s : UML2!SendSignalAction
    to t : UML2!SendSignalAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        target <- s.target,
        localPostcondition <- s.localPostcondition,
        signal <- s.signal,
        redefinedElement <- s.redefinedElement,
        onPort <- s.onPort,
        argument <- s.argument,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Comment {
    from s : UML2!Comment
    to t : UML2!Comment mapsTo s (
        body <- s.body,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        annotatedElement <- s.annotatedElement,
        ownedComment <- s.ownedComment,
        bodyExpression <- s.bodyExpression)
}

rule InputPin {
    from s : UML2!InputPin (s.oclIsTypeOf(UML2!InputPin))
    to t : UML2!InputPin mapsTo s (
        ordering <- s.ordering,
        isOrdered <- s.isOrdered,
        visibility <- s.visibility,
        isUnique <- s.isUnique,
        name <- s.name,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        upperValue <- s.upperValue,
        upperBound <- s.upperBound,
        selection <- s.selection,
        redefinedElement <- s.redefinedElement,
        inState <- s.inState,
        lowerValue <- s.lowerValue,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule LiteralUnlimitedNatural {
    from s : UML2!LiteralUnlimitedNatural
    to t : UML2!LiteralUnlimitedNatural mapsTo s (
        visibility <- s.visibility,
        value <- s.value,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Component {
    from s : UML2!Component
    to t : UML2!Component mapsTo s (
        isActive <- s.isActive,
        isIndirectlyInstantiated <- s.isIndirectlyInstantiated,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTrigger <- s.ownedTrigger,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        nestedClassifier <- s.nestedClassifier,
        ownedPort <- s.ownedPort,
        ownedMember <- s.ownedMember,
        ownedStateMachine <- s.ownedStateMachine,
        implementation <- s.implementation,
        generalization <- s.generalization,
        substitution <- s.substitution,
        ownedBehavior <- s.ownedBehavior,
        occurrence <- s.occurrence,
        ownedOperation <- s.ownedOperation,
        ownedRule <- s.ownedRule,
        redefinedClassifier <- s.redefinedClassifier,
        ownedConnector <- s.ownedConnector,
        elementImport <- s.elementImport,
        ownedReception <- s.ownedReception,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        ownedAttribute <- s.ownedAttribute,
        representation <- s.representation,
        realization <- s.realization,
        classifierBehavior <- s.classifierBehavior,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule ActivityFinalNode {
    from s : UML2!ActivityFinalNode
    to t : UML2!ActivityFinalNode mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        redefinedElement <- s.redefinedElement,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Activity {
    from s : UML2!Activity
    to t : UML2!Activity mapsTo s (
        isReadOnly <- s.isReadOnly,
        language <- s.language,
        isActive <- s.isActive,
        isSingleExecution <- s.isSingleExecution,
        isAbstract <- s.isAbstract,
        isReentrant <- s.isReentrant,
        visibility <- s.visibility,
        body <- s.body,
        name <- s.name,
        isLeaf <- s.isLeaf,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        action <- s.action,
        templateBinding <- s.templateBinding,
        ownedTrigger <- s.ownedTrigger,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        nestedClassifier <- s.nestedClassifier,
        ownedPort <- s.ownedPort,
        edge <- s.edge,
        ownedStateMachine <- s.ownedStateMachine,
        implementation <- s.implementation,
        generalization <- s.generalization,
        substitution <- s.substitution,
        ownedBehavior <- s.ownedBehavior,
        occurrence <- s.occurrence,
        ownedOperation <- s.ownedOperation,
        ownedRule <- s.ownedRule,
        group <- s.group,
        ownedParameterSet <- s.ownedParameterSet,
        precondition <- s.precondition,
        redefinedClassifier <- s.redefinedClassifier,
        ownedConnector <- s.ownedConnector,
        elementImport <- s.elementImport,
        redefinedBehavior <- s.redefinedBehavior,
        ownedReception <- s.ownedReception,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        ownedAttribute <- s.ownedAttribute,
        representation <- s.representation,
        postcondition <- s.postcondition,
        parameter <- s.parameter,
        classifierBehavior <- s.classifierBehavior,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression,
        node <- s.node)
}

rule Class {
    from s : UML2!Class (s.oclIsTypeOf(UML2!Class))
    to t : UML2!Class mapsTo s (
        isActive <- s.isActive,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTrigger <- s.ownedTrigger,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        nestedClassifier <- s.nestedClassifier,
        ownedPort <- s.ownedPort,
        ownedStateMachine <- s.ownedStateMachine,
        implementation <- s.implementation,
        generalization <- s.generalization,
        substitution <- s.substitution,
        ownedBehavior <- s.ownedBehavior,
        occurrence <- s.occurrence,
        ownedOperation <- s.ownedOperation,
        ownedRule <- s.ownedRule,
        redefinedClassifier <- s.redefinedClassifier,
        ownedConnector <- s.ownedConnector,
        elementImport <- s.elementImport,
        ownedReception <- s.ownedReception,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        ownedAttribute <- s.ownedAttribute,
        representation <- s.representation,
        classifierBehavior <- s.classifierBehavior,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule Action {
    from s : UML2!Action (s.oclIsTypeOf(UML2!Action))
    to t : UML2!Action mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule RemoveStructuralFeatureValueAction {
    from s : UML2!RemoveStructuralFeatureValueAction
    to t : UML2!RemoveStructuralFeatureValueAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        value <- s.value,
        structuralFeature <- s.structuralFeature,
        object <- s.object,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule RaiseExceptionAction {
    from s : UML2!RaiseExceptionAction
    to t : UML2!RaiseExceptionAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        exception <- s.exception,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Permission {
    from s : UML2!Permission
    to t : UML2!Permission mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        supplier <- s.supplier,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Duration {
    from s : UML2!Duration
    to t : UML2!Duration mapsTo s (
        firstTime <- s.firstTime,
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        event <- s.event,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Interface {
    from s : UML2!Interface
    to t : UML2!Interface mapsTo s (
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        protocol <- s.protocol,
        ownedAttribute <- s.ownedAttribute,
        generalization <- s.generalization,
        substitution <- s.substitution,
        occurrence <- s.occurrence,
        ownedRule <- s.ownedRule,
        redefinedInterface <- s.redefinedInterface,
        redefinedClassifier <- s.redefinedClassifier,
        elementImport <- s.elementImport,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        representation <- s.representation,
        ownedOperation <- s.ownedOperation,
        packageImport <- s.packageImport,
        nestedClassifier <- s.nestedClassifier,
        nameExpression <- s.nameExpression,
        ownedReception <- s.ownedReception)
}

rule AcceptCallAction {
    from s : UML2!AcceptCallAction
    to t : UML2!AcceptCallAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        trigger <- s.trigger,
        localPostcondition <- s.localPostcondition,
        returnInformation <- s.returnInformation,
        result <- s.result,
        redefinedElement <- s.redefinedElement,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule TimeExpression {
    from s : UML2!TimeExpression
    to t : UML2!TimeExpression mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        firstTime <- s.firstTime,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        event <- s.event,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Actor {
    from s : UML2!Actor
    to t : UML2!Actor mapsTo s (
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        substitution <- s.substitution,
        occurrence <- s.occurrence,
        ownedRule <- s.ownedRule,
        redefinedClassifier <- s.redefinedClassifier,
        elementImport <- s.elementImport,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        representation <- s.representation,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule Property {
    from s : UML2!Property (s.oclIsTypeOf(UML2!Property))
    to t : UML2!Property mapsTo s (
        isStatic <- s.isStatic,
        isDerivedUnion <- s.isDerivedUnion,
        isReadOnly <- s.isReadOnly,
        isOrdered <- s.isOrdered,
        visibility <- s.visibility,
        isUnique <- s.isUnique,
        name <- s.name,
        isLeaf <- s.isLeaf,
        isDerived <- s.isDerived,
        aggregation <- s.aggregation,
        eAnnotations <- s.eAnnotations,
        subsettedProperty <- s.subsettedProperty,
        defaultValue <- s.defaultValue,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        upperValue <- s.upperValue,
        redefinedProperty <- s.redefinedProperty,
        deployment <- s.deployment,
        qualifier <- s.qualifier,
        lowerValue <- s.lowerValue,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ProtocolStateMachine {
    from s : UML2!ProtocolStateMachine
    to t : UML2!ProtocolStateMachine mapsTo s (
        isActive <- s.isActive,
        isAbstract <- s.isAbstract,
        isReentrant <- s.isReentrant,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        extendedStateMachine <- s.extendedStateMachine,
        templateBinding <- s.templateBinding,
        ownedTrigger <- s.ownedTrigger,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        nestedClassifier <- s.nestedClassifier,
        ownedPort <- s.ownedPort,
        ownedStateMachine <- s.ownedStateMachine,
        implementation <- s.implementation,
        generalization <- s.generalization,
        substitution <- s.substitution,
        ownedBehavior <- s.ownedBehavior,
        occurrence <- s.occurrence,
        ownedOperation <- s.ownedOperation,
        ownedRule <- s.ownedRule,
        ownedParameterSet <- s.ownedParameterSet,
        connectionPoint <- s.connectionPoint,
        precondition <- s.precondition,
        redefinedClassifier <- s.redefinedClassifier,
        ownedConnector <- s.ownedConnector,
        elementImport <- s.elementImport,
        redefinedBehavior <- s.redefinedBehavior,
        ownedReception <- s.ownedReception,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        ownedAttribute <- s.ownedAttribute,
        conformance <- s.conformance,
        representation <- s.representation,
        postcondition <- s.postcondition,
        parameter <- s.parameter,
        classifierBehavior <- s.classifierBehavior,
        region <- s.region,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule Generalization {
    from s : UML2!Generalization
    to t : UML2!Generalization mapsTo s (
        isSubstitutable <- s.isSubstitutable,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        general <- s.general)
}

rule AssociationClass {
    from s : UML2!AssociationClass
    to t : UML2!AssociationClass mapsTo s (
        isActive <- s.isActive,
        isDerived <- s.isDerived,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTrigger <- s.ownedTrigger,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        nestedClassifier <- s.nestedClassifier,
        ownedPort <- s.ownedPort,
        ownedStateMachine <- s.ownedStateMachine,
        implementation <- s.implementation,
        generalization <- s.generalization,
        substitution <- s.substitution,
        ownedBehavior <- s.ownedBehavior,
        occurrence <- s.occurrence,
        ownedOperation <- s.ownedOperation,
        ownedRule <- s.ownedRule,
        redefinedClassifier <- s.redefinedClassifier,
        ownedConnector <- s.ownedConnector,
        elementImport <- s.elementImport,
        ownedReception <- s.ownedReception,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        ownedAttribute <- s.ownedAttribute,
        representation <- s.representation,
        classifierBehavior <- s.classifierBehavior,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression,
        ownedEnd <- s.ownedEnd)
}

rule Package {
    from s : UML2!Package (s.oclIsTypeOf(UML2!Package))
    to t : UML2!Package mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        ownedMember <- s.ownedMember,
        appliedProfile <- s.appliedProfile,
        packageExtension <- s.packageExtension,
        ownedRule <- s.ownedRule,
        packageMerge <- s.packageMerge,
        elementImport <- s.elementImport,
        ownedComment <- s.ownedComment,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule Enumeration {
    from s : UML2!Enumeration
    to t : UML2!Enumeration mapsTo s (
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        ownedAttribute <- s.ownedAttribute,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        substitution <- s.substitution,
        occurrence <- s.occurrence,
        ownedRule <- s.ownedRule,
        ownedOperation <- s.ownedOperation,
        ownedLiteral <- s.ownedLiteral,
        redefinedClassifier <- s.redefinedClassifier,
        elementImport <- s.elementImport,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        representation <- s.representation,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule InterruptibleActivityRegion {
    from s : UML2!InterruptibleActivityRegion
    to t : UML2!InterruptibleActivityRegion mapsTo s (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment)
}

rule DeploymentSpecification {
    from s : UML2!DeploymentSpecification
    to t : UML2!DeploymentSpecification mapsTo s (
        deploymentLocation <- s.deploymentLocation,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        executionLocation <- s.executionLocation,
        name <- s.name,
        isLeaf <- s.isLeaf,
        fileName <- s.fileName,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        ownedOperation <- s.ownedOperation,
        generalization <- s.generalization,
        substitution <- s.substitution,
        occurrence <- s.occurrence,
        ownedRule <- s.ownedRule,
        redefinedClassifier <- s.redefinedClassifier,
        ownedAttribute <- s.ownedAttribute,
        elementImport <- s.elementImport,
        manifestation <- s.manifestation,
        nestedArtifact <- s.nestedArtifact,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        representation <- s.representation,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule UseCase {
    from s : UML2!UseCase
    to t : UML2!UseCase mapsTo s (
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTrigger <- s.ownedTrigger,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        ownedStateMachine <- s.ownedStateMachine,
        implementation <- s.implementation,
        extensionPoint <- s.extensionPoint,
        generalization <- s.generalization,
        substitution <- s.substitution,
        ownedBehavior <- s.ownedBehavior,
        occurrence <- s.occurrence,
        ownedRule <- s.ownedRule,
        redefinedClassifier <- s.redefinedClassifier,
        extend <- s.extend,
        elementImport <- s.elementImport,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        include <- s.include,
        representation <- s.representation,
        classifierBehavior <- s.classifierBehavior,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule InstanceSpecification {
    from s : UML2!InstanceSpecification (s.oclIsTypeOf(UML2!InstanceSpecification))
    to t : UML2!InstanceSpecification mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        slot <- s.slot,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        deployment <- s.deployment,
        specification <- s.specification,
        classifier <- s.classifier,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ReadLinkObjectEndAction {
    from s : UML2!ReadLinkObjectEndAction
    to t : UML2!ReadLinkObjectEndAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        object <- s.object,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        result <- s.result,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        end <- s.end,
        nameExpression <- s.nameExpression)
}

rule Usage {
    from s : UML2!Usage
    to t : UML2!Usage mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        supplier <- s.supplier,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ExpansionNode {
    from s : UML2!ExpansionNode
    to t : UML2!ExpansionNode mapsTo s (
        ordering <- s.ordering,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        upperBound <- s.upperBound,
        selection <- s.selection,
        redefinedElement <- s.redefinedElement,
        inState <- s.inState,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ConditionalNode {
    from s : UML2!ConditionalNode
    to t : UML2!ConditionalNode mapsTo s (
        visibility <- s.visibility,
        isAssured <- s.isAssured,
        name <- s.name,
        isLeaf <- s.isLeaf,
        isDeterminate <- s.isDeterminate,
        effect <- s.effect,
        mustIsolate <- s.mustIsolate,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        containedNode <- s.containedNode,
        clause <- s.clause,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        ownedRule <- s.ownedRule,
        containedEdge <- s.containedEdge,
        result <- s.result,
        elementImport <- s.elementImport,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        packageImport <- s.packageImport,
        variable <- s.variable,
        nameExpression <- s.nameExpression)
}

rule QualifierValue {
    from s : UML2!QualifierValue
    to t : UML2!QualifierValue mapsTo s (
        qualifier <- s.qualifier,
        eAnnotations <- s.eAnnotations,
        value <- s.value,
        ownedComment <- s.ownedComment)
}

rule Variable {
    from s : UML2!Variable
    to t : UML2!Variable mapsTo s (
        isOrdered <- s.isOrdered,
        visibility <- s.visibility,
        isUnique <- s.isUnique,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Implementation {
    from s : UML2!Implementation
    to t : UML2!Implementation mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        supplier <- s.supplier,
        realizingClassifier <- s.realizingClassifier,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        mapping <- s.mapping,
        ownedComment <- s.ownedComment,
        contract <- s.contract,
        nameExpression <- s.nameExpression)
}

rule DestroyObjectAction {
    from s : UML2!DestroyObjectAction
    to t : UML2!DestroyObjectAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        isDestroyLinks <- s.isDestroyLinks,
        isDestroyOwnedObjects <- s.isDestroyOwnedObjects,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        target <- s.target,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ValuePin {
    from s : UML2!ValuePin
    to t : UML2!ValuePin mapsTo s (
        ordering <- s.ordering,
        isOrdered <- s.isOrdered,
        visibility <- s.visibility,
        isUnique <- s.isUnique,
        name <- s.name,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        upperValue <- s.upperValue,
        upperBound <- s.upperBound,
        selection <- s.selection,
        redefinedElement <- s.redefinedElement,
        inState <- s.inState,
        lowerValue <- s.lowerValue,
        type <- s.type,
        ownedComment <- s.ownedComment,
        value <- s.value,
        nameExpression <- s.nameExpression)
}

rule GeneralizationSet {
    from s : UML2!GeneralizationSet
    to t : UML2!GeneralizationSet mapsTo s (
        isDisjoint <- s.isDisjoint,
        visibility <- s.visibility,
        isCovering <- s.isCovering,
        name <- s.name,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule InstanceValue {
    from s : UML2!InstanceValue
    to t : UML2!InstanceValue mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        type <- s.type,
        ownedComment <- s.ownedComment,
        instance <- s.instance,
        nameExpression <- s.nameExpression)
}

rule ControlFlow {
    from s : UML2!ControlFlow
    to t : UML2!ControlFlow mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        weight <- s.weight,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        redefinedElement <- s.redefinedElement,
        guard <- s.guard,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Port {
    from s : UML2!Port
    to t : UML2!Port mapsTo s (
        isBehavior <- s.isBehavior,
        isStatic <- s.isStatic,
        isDerivedUnion <- s.isDerivedUnion,
        isReadOnly <- s.isReadOnly,
        isOrdered <- s.isOrdered,
        visibility <- s.visibility,
        isUnique <- s.isUnique,
        name <- s.name,
        isLeaf <- s.isLeaf,
        isDerived <- s.isDerived,
        aggregation <- s.aggregation,
        isService <- s.isService,
        eAnnotations <- s.eAnnotations,
        redefinedPort <- s.redefinedPort,
        subsettedProperty <- s.subsettedProperty,
        defaultValue <- s.defaultValue,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        upperValue <- s.upperValue,
        redefinedProperty <- s.redefinedProperty,
        deployment <- s.deployment,
        qualifier <- s.qualifier,
        lowerValue <- s.lowerValue,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression,
        protocol <- s.protocol)
}

rule ReadIsClassifiedObjectAction {
    from s : UML2!ReadIsClassifiedObjectAction
    to t : UML2!ReadIsClassifiedObjectAction mapsTo s (
        isDirect <- s.isDirect,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        result <- s.result,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        classifier <- s.classifier,
        object <- s.object,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule SendObjectAction {
    from s : UML2!SendObjectAction
    to t : UML2!SendObjectAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        target <- s.target,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        onPort <- s.onPort,
        request <- s.request,
        argument <- s.argument,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Abstraction {
    from s : UML2!Abstraction (s.oclIsTypeOf(UML2!Abstraction))
    to t : UML2!Abstraction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        supplier <- s.supplier,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        mapping <- s.mapping,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule StateMachine {
    from s : UML2!StateMachine (s.oclIsTypeOf(UML2!StateMachine))
    to t : UML2!StateMachine mapsTo s (
        isActive <- s.isActive,
        isAbstract <- s.isAbstract,
        isReentrant <- s.isReentrant,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        extendedStateMachine <- s.extendedStateMachine,
        templateBinding <- s.templateBinding,
        ownedTrigger <- s.ownedTrigger,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        nestedClassifier <- s.nestedClassifier,
        ownedPort <- s.ownedPort,
        ownedStateMachine <- s.ownedStateMachine,
        implementation <- s.implementation,
        generalization <- s.generalization,
        substitution <- s.substitution,
        ownedBehavior <- s.ownedBehavior,
        occurrence <- s.occurrence,
        ownedOperation <- s.ownedOperation,
        ownedRule <- s.ownedRule,
        ownedParameterSet <- s.ownedParameterSet,
        connectionPoint <- s.connectionPoint,
        precondition <- s.precondition,
        redefinedClassifier <- s.redefinedClassifier,
        ownedConnector <- s.ownedConnector,
        elementImport <- s.elementImport,
        redefinedBehavior <- s.redefinedBehavior,
        ownedReception <- s.ownedReception,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        ownedAttribute <- s.ownedAttribute,
        representation <- s.representation,
        postcondition <- s.postcondition,
        parameter <- s.parameter,
        classifierBehavior <- s.classifierBehavior,
        region <- s.region,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule MergeNode {
    from s : UML2!MergeNode
    to t : UML2!MergeNode mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        redefinedElement <- s.redefinedElement,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Extend {
    from s : UML2!Extend
    to t : UML2!Extend mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        extendedCase <- s.extendedCase,
        ownedComment <- s.ownedComment,
        condition <- s.condition,
        extensionLocation <- s.extensionLocation,
        nameExpression <- s.nameExpression)
}

rule EAnnotation {
    from s : UML2!EAnnotation
    to t : UML2!EAnnotation mapsTo s (
        source <- s.source,
        details <- s.details,
        references <- s.references,
        contents <- s.contents,
        eAnnotations <- s.eAnnotations)
}

rule JoinNode {
    from s : UML2!JoinNode
    to t : UML2!JoinNode mapsTo s (
        isCombineDuplicate <- s.isCombineDuplicate,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        redefinedElement <- s.redefinedElement,
        ownedComment <- s.ownedComment,
        joinSpec <- s.joinSpec,
        nameExpression <- s.nameExpression)
}

rule FinalState {
    from s : UML2!FinalState
    to t : UML2!FinalState mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        redefinedState <- s.redefinedState,
        entry <- s.entry,
        stateInvariant <- s.stateInvariant,
        templateBinding <- s.templateBinding,
        exit <- s.exit,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        region <- s.region,
        doActivity <- s.doActivity,
        submachine <- s.submachine,
        deferrableTrigger <- s.deferrableTrigger,
        ownedRule <- s.ownedRule,
        elementImport <- s.elementImport,
        connection <- s.connection,
        ownedComment <- s.ownedComment,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule OperationTemplateParameter {
    from s : UML2!OperationTemplateParameter
    to t : UML2!OperationTemplateParameter mapsTo s (
        eAnnotations <- s.eAnnotations,
        default <- s.default,
        ownedDefault <- s.ownedDefault,
        ownedComment <- s.ownedComment,
        ownedParameteredElement <- s.ownedParameteredElement)
}

rule EventOccurrence {
    from s : UML2!EventOccurrence (s.oclIsTypeOf(UML2!EventOccurrence))
    to t : UML2!EventOccurrence mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalOrdering <- s.generalOrdering,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule StateInvariant {
    from s : UML2!StateInvariant
    to t : UML2!StateInvariant mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalOrdering <- s.generalOrdering,
        invariant <- s.invariant,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ForkNode {
    from s : UML2!ForkNode
    to t : UML2!ForkNode mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        redefinedElement <- s.redefinedElement,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ExecutionOccurrence {
    from s : UML2!ExecutionOccurrence
    to t : UML2!ExecutionOccurrence mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalOrdering <- s.generalOrdering,
        ownedComment <- s.ownedComment,
        behavior <- s.behavior,
        nameExpression <- s.nameExpression)
}

rule ReadStructuralFeatureAction {
    from s : UML2!ReadStructuralFeatureAction
    to t : UML2!ReadStructuralFeatureAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        structuralFeature <- s.structuralFeature,
        object <- s.object,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        result <- s.result,
        nameExpression <- s.nameExpression)
}

rule StartOwnedBehaviorAction {
    from s : UML2!StartOwnedBehaviorAction
    to t : UML2!StartOwnedBehaviorAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        object <- s.object,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ConnectionPointReference {
    from s : UML2!ConnectionPointReference
    to t : UML2!ConnectionPointReference mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        entry <- s.entry,
        exit <- s.exit,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule CreateLinkAction {
    from s : UML2!CreateLinkAction (s.oclIsTypeOf(UML2!CreateLinkAction))
    to t : UML2!CreateLinkAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        endData <- s.endData,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Stop {
    from s : UML2!Stop
    to t : UML2!Stop mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalOrdering <- s.generalOrdering,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ExtensionEnd {
    from s : UML2!ExtensionEnd
    to t : UML2!ExtensionEnd mapsTo s (
        isStatic <- s.isStatic,
        isDerivedUnion <- s.isDerivedUnion,
        isReadOnly <- s.isReadOnly,
        isOrdered <- s.isOrdered,
        visibility <- s.visibility,
        isUnique <- s.isUnique,
        name <- s.name,
        isLeaf <- s.isLeaf,
        isDerived <- s.isDerived,
        aggregation <- s.aggregation,
        eAnnotations <- s.eAnnotations,
        subsettedProperty <- s.subsettedProperty,
        defaultValue <- s.defaultValue,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        upperValue <- s.upperValue,
        redefinedProperty <- s.redefinedProperty,
        deployment <- s.deployment,
        qualifier <- s.qualifier,
        lowerValue <- s.lowerValue,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule IntervalConstraint {
    from s : UML2!IntervalConstraint (s.oclIsTypeOf(UML2!IntervalConstraint))
    to t : UML2!IntervalConstraint mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        constrainedElement <- s.constrainedElement,
        specification <- s.specification,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule InitialNode {
    from s : UML2!InitialNode
    to t : UML2!InitialNode mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        redefinedElement <- s.redefinedElement,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Parameter {
    from s : UML2!Parameter
    to t : UML2!Parameter mapsTo s (
        effect <- s.effect,
        isStream <- s.isStream,
        direction <- s.direction,
        isException <- s.isException,
        isOrdered <- s.isOrdered,
        visibility <- s.visibility,
        isUnique <- s.isUnique,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        upperValue <- s.upperValue,
        defaultValue <- s.defaultValue,
        lowerValue <- s.lowerValue,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ClassifierTemplateParameter {
    from s : UML2!ClassifierTemplateParameter
    to t : UML2!ClassifierTemplateParameter mapsTo s (
        allowSubstitutable <- s.allowSubstitutable,
        eAnnotations <- s.eAnnotations,
        default <- s.default,
        ownedDefault <- s.ownedDefault,
        ownedComment <- s.ownedComment,
        ownedParameteredElement <- s.ownedParameteredElement)
}

rule ReclassifyObjectAction {
    from s : UML2!ReclassifyObjectAction
    to t : UML2!ReclassifyObjectAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        isReplaceAll <- s.isReplaceAll,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        newClassifier <- s.newClassifier,
        oldClassifier <- s.oldClassifier,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        object <- s.object,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule TemplateParameter {
    from s : UML2!TemplateParameter (s.oclIsTypeOf(UML2!TemplateParameter))
    to t : UML2!TemplateParameter mapsTo s (
        eAnnotations <- s.eAnnotations,
        default <- s.default,
        ownedDefault <- s.ownedDefault,
        ownedComment <- s.ownedComment,
        ownedParameteredElement <- s.ownedParameteredElement)
}

rule Association {
    from s : UML2!Association (s.oclIsTypeOf(UML2!Association))
    to t : UML2!Association mapsTo s (
        isDerived <- s.isDerived,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        substitution <- s.substitution,
        occurrence <- s.occurrence,
        ownedRule <- s.ownedRule,
        redefinedClassifier <- s.redefinedClassifier,
        elementImport <- s.elementImport,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        representation <- s.representation,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression,
        ownedEnd <- s.ownedEnd)
}

rule CreateLinkObjectAction {
    from s : UML2!CreateLinkObjectAction
    to t : UML2!CreateLinkObjectAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        result <- s.result,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        endData <- s.endData,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule CommunicationPath {
    from s : UML2!CommunicationPath
    to t : UML2!CommunicationPath mapsTo s (
        isDerived <- s.isDerived,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        substitution <- s.substitution,
        occurrence <- s.occurrence,
        ownedRule <- s.ownedRule,
        redefinedClassifier <- s.redefinedClassifier,
        elementImport <- s.elementImport,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        representation <- s.representation,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression,
        ownedEnd <- s.ownedEnd)
}

rule Collaboration {
    from s : UML2!Collaboration
    to t : UML2!Collaboration mapsTo s (
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTrigger <- s.ownedTrigger,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        collaborationRole <- s.collaborationRole,
        ownedStateMachine <- s.ownedStateMachine,
        implementation <- s.implementation,
        generalization <- s.generalization,
        substitution <- s.substitution,
        ownedBehavior <- s.ownedBehavior,
        occurrence <- s.occurrence,
        ownedRule <- s.ownedRule,
        redefinedClassifier <- s.redefinedClassifier,
        ownedConnector <- s.ownedConnector,
        elementImport <- s.elementImport,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        ownedAttribute <- s.ownedAttribute,
        representation <- s.representation,
        classifierBehavior <- s.classifierBehavior,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule EStringToStringMapEntry {
    from s : UML2!EStringToStringMapEntry
    to t : UML2!EStringToStringMapEntry mapsTo s (
        value <- s.value,
        key <- s.key)
}

rule PackageImport {
    from s : UML2!PackageImport (s.oclIsTypeOf(UML2!PackageImport))
    to t : UML2!PackageImport mapsTo s (
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        importedPackage <- s.importedPackage)
}

rule InteractionOccurrence {
    from s : UML2!InteractionOccurrence (s.oclIsTypeOf(UML2!InteractionOccurrence))
    to t : UML2!InteractionOccurrence mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        refersTo <- s.refersTo,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        argument <- s.argument,
        generalOrdering <- s.generalOrdering,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression,
        actualGate <- s.actualGate)
}

rule ProtocolTransition {
    from s : UML2!ProtocolTransition
    to t : UML2!ProtocolTransition mapsTo s (
        kind <- s.kind,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        postCondition <- s.postCondition,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        guard <- s.guard,
        redefinedTransition <- s.redefinedTransition,
        trigger <- s.trigger,
        effect <- s.effect,
        preCondition <- s.preCondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ReadExtentAction {
    from s : UML2!ReadExtentAction
    to t : UML2!ReadExtentAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        classifier <- s.classifier,
        result <- s.result,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ClearVariableAction {
    from s : UML2!ClearVariableAction
    to t : UML2!ClearVariableAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        variable <- s.variable,
        redefinedElement <- s.redefinedElement,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ParameterSet {
    from s : UML2!ParameterSet
    to t : UML2!ParameterSet mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        condition <- s.condition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule PrimitiveType {
    from s : UML2!PrimitiveType
    to t : UML2!PrimitiveType mapsTo s (
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        ownedAttribute <- s.ownedAttribute,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        substitution <- s.substitution,
        occurrence <- s.occurrence,
        ownedRule <- s.ownedRule,
        ownedOperation <- s.ownedOperation,
        redefinedClassifier <- s.redefinedClassifier,
        elementImport <- s.elementImport,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        representation <- s.representation,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule InteractionConstraint {
    from s : UML2!InteractionConstraint
    to t : UML2!InteractionConstraint mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        constrainedElement <- s.constrainedElement,
        specification <- s.specification,
        minint <- s.minint,
        ownedComment <- s.ownedComment,
        maxint <- s.maxint,
        nameExpression <- s.nameExpression)
}

rule ElementImport {
    from s : UML2!ElementImport
    to t : UML2!ElementImport mapsTo s (
        visibility <- s.visibility,
        alias <- s.alias,
        eAnnotations <- s.eAnnotations,
        importedElement <- s.importedElement,
        ownedComment <- s.ownedComment)
}

rule StructuredActivityNode {
    from s : UML2!StructuredActivityNode (s.oclIsTypeOf(UML2!StructuredActivityNode))
    to t : UML2!StructuredActivityNode mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        mustIsolate <- s.mustIsolate,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        containedNode <- s.containedNode,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        ownedRule <- s.ownedRule,
        containedEdge <- s.containedEdge,
        elementImport <- s.elementImport,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        packageImport <- s.packageImport,
        variable <- s.variable,
        nameExpression <- s.nameExpression)
}

rule Connector {
    from s : UML2!Connector
    to t : UML2!Connector mapsTo s (
        isStatic <- s.isStatic,
        visibility <- s.visibility,
        kind <- s.kind,
        name <- s.name,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        end <- s.end,
        redefinedConnector <- s.redefinedConnector,
        type <- s.type,
        ownedComment <- s.ownedComment,
        contract <- s.contract,
        nameExpression <- s.nameExpression)
}

rule TemplateSignature {
    from s : UML2!TemplateSignature (s.oclIsTypeOf(UML2!TemplateSignature))
    to t : UML2!TemplateSignature mapsTo s (
        eAnnotations <- s.eAnnotations,
        parameter <- s.parameter,
        ownedParameter <- s.ownedParameter,
        ownedComment <- s.ownedComment)
}

rule Pseudostate {
    from s : UML2!Pseudostate
    to t : UML2!Pseudostate mapsTo s (
        kind <- s.kind,
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule StringExpression {
    from s : UML2!StringExpression
    to t : UML2!StringExpression mapsTo s (
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        subExpression <- s.subExpression,
        ownedComment <- s.ownedComment)
}

rule AddStructuralFeatureValueAction {
    from s : UML2!AddStructuralFeatureValueAction
    to t : UML2!AddStructuralFeatureValueAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        isReplaceAll <- s.isReplaceAll,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        value <- s.value,
        insertAt <- s.insertAt,
        structuralFeature <- s.structuralFeature,
        object <- s.object,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Region {
    from s : UML2!Region
    to t : UML2!Region mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        transition <- s.transition,
        subvertex <- s.subvertex,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        extendedRegion <- s.extendedRegion,
        ownedRule <- s.ownedRule,
        elementImport <- s.elementImport,
        ownedComment <- s.ownedComment,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule Expression {
    from s : UML2!Expression
    to t : UML2!Expression mapsTo s (
        language <- s.language,
        visibility <- s.visibility,
        body <- s.body,
        name <- s.name,
        symbol <- s.symbol,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        operand <- s.operand,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        behavior <- s.behavior,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Manifestation {
    from s : UML2!Manifestation
    to t : UML2!Manifestation mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        supplier <- s.supplier,
        utilizedElement <- s.utilizedElement,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        mapping <- s.mapping,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule LinkEndData {
    from s : UML2!LinkEndData (s.oclIsTypeOf(UML2!LinkEndData))
    to t : UML2!LinkEndData mapsTo s (
        eAnnotations <- s.eAnnotations,
        value <- s.value,
        qualifier <- s.qualifier,
        ownedComment <- s.ownedComment,
        end <- s.end)
}

rule TimeConstraint {
    from s : UML2!TimeConstraint
    to t : UML2!TimeConstraint mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        constrainedElement <- s.constrainedElement,
        specification <- s.specification,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule InteractionOperand {
    from s : UML2!InteractionOperand
    to t : UML2!InteractionOperand mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        guard <- s.guard,
        generalOrdering <- s.generalOrdering,
        ownedRule <- s.ownedRule,
        elementImport <- s.elementImport,
        ownedComment <- s.ownedComment,
        fragment <- s.fragment,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule Device {
    from s : UML2!Device
    to t : UML2!Device mapsTo s (
        isActive <- s.isActive,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTrigger <- s.ownedTrigger,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        nestedClassifier <- s.nestedClassifier,
        ownedPort <- s.ownedPort,
        ownedStateMachine <- s.ownedStateMachine,
        implementation <- s.implementation,
        generalization <- s.generalization,
        substitution <- s.substitution,
        ownedBehavior <- s.ownedBehavior,
        occurrence <- s.occurrence,
        ownedOperation <- s.ownedOperation,
        nestedNode <- s.nestedNode,
        deployment <- s.deployment,
        ownedRule <- s.ownedRule,
        redefinedClassifier <- s.redefinedClassifier,
        ownedConnector <- s.ownedConnector,
        elementImport <- s.elementImport,
        ownedReception <- s.ownedReception,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        ownedAttribute <- s.ownedAttribute,
        representation <- s.representation,
        classifierBehavior <- s.classifierBehavior,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule EnumerationLiteral {
    from s : UML2!EnumerationLiteral
    to t : UML2!EnumerationLiteral mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        slot <- s.slot,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        deployment <- s.deployment,
        specification <- s.specification,
        classifier <- s.classifier,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule TestIdentityAction {
    from s : UML2!TestIdentityAction
    to t : UML2!TestIdentityAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        second <- s.second,
        localPostcondition <- s.localPostcondition,
        first <- s.first,
        redefinedElement <- s.redefinedElement,
        result <- s.result,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule CallOperationAction {
    from s : UML2!CallOperationAction
    to t : UML2!CallOperationAction mapsTo s (
        isSynchronous <- s.isSynchronous,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        result <- s.result,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        onPort <- s.onPort,
        operation <- s.operation,
        target <- s.target,
        argument <- s.argument,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule LinkEndCreationData {
    from s : UML2!LinkEndCreationData
    to t : UML2!LinkEndCreationData mapsTo s (
        isReplaceAll <- s.isReplaceAll,
        eAnnotations <- s.eAnnotations,
        insertAt <- s.insertAt,
        value <- s.value,
        qualifier <- s.qualifier,
        ownedComment <- s.ownedComment,
        end <- s.end)
}

rule DataType {
    from s : UML2!DataType (s.oclIsTypeOf(UML2!DataType))
    to t : UML2!DataType mapsTo s (
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        ownedAttribute <- s.ownedAttribute,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        substitution <- s.substitution,
        occurrence <- s.occurrence,
        ownedRule <- s.ownedRule,
        ownedOperation <- s.ownedOperation,
        redefinedClassifier <- s.redefinedClassifier,
        elementImport <- s.elementImport,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        representation <- s.representation,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule ExpansionRegion {
    from s : UML2!ExpansionRegion
    to t : UML2!ExpansionRegion mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        mode <- s.mode,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        mustIsolate <- s.mustIsolate,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        containedNode <- s.containedNode,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        ownedRule <- s.ownedRule,
        containedEdge <- s.containedEdge,
        elementImport <- s.elementImport,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        packageImport <- s.packageImport,
        variable <- s.variable,
        nameExpression <- s.nameExpression)
}

rule Gate {
    from s : UML2!Gate
    to t : UML2!Gate mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ChangeTrigger {
    from s : UML2!ChangeTrigger
    to t : UML2!ChangeTrigger mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        changeExpression <- s.changeExpression,
        port <- s.port,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule Transition {
    from s : UML2!Transition (s.oclIsTypeOf(UML2!Transition))
    to t : UML2!Transition mapsTo s (
        kind <- s.kind,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        guard <- s.guard,
        redefinedTransition <- s.redefinedTransition,
        trigger <- s.trigger,
        effect <- s.effect,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ExceptionHandler {
    from s : UML2!ExceptionHandler
    to t : UML2!ExceptionHandler mapsTo s (
        eAnnotations <- s.eAnnotations,
        exceptionType <- s.exceptionType,
        exceptionInput <- s.exceptionInput,
        handlerBody <- s.handlerBody,
        ownedComment <- s.ownedComment)
}

rule ConnectableElementTemplateParameter {
    from s : UML2!ConnectableElementTemplateParameter
    to t : UML2!ConnectableElementTemplateParameter mapsTo s (
        eAnnotations <- s.eAnnotations,
        default <- s.default,
        ownedDefault <- s.ownedDefault,
        ownedComment <- s.ownedComment,
        ownedParameteredElement <- s.ownedParameteredElement)
}

rule Node {
    from s : UML2!Node (s.oclIsTypeOf(UML2!Node))
    to t : UML2!Node mapsTo s (
        isActive <- s.isActive,
        isAbstract <- s.isAbstract,
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTrigger <- s.ownedTrigger,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        nestedClassifier <- s.nestedClassifier,
        ownedPort <- s.ownedPort,
        ownedStateMachine <- s.ownedStateMachine,
        implementation <- s.implementation,
        generalization <- s.generalization,
        substitution <- s.substitution,
        ownedBehavior <- s.ownedBehavior,
        occurrence <- s.occurrence,
        ownedOperation <- s.ownedOperation,
        nestedNode <- s.nestedNode,
        deployment <- s.deployment,
        ownedRule <- s.ownedRule,
        redefinedClassifier <- s.redefinedClassifier,
        ownedConnector <- s.ownedConnector,
        elementImport <- s.elementImport,
        ownedReception <- s.ownedReception,
        ownedUseCase <- s.ownedUseCase,
        ownedComment <- s.ownedComment,
        ownedAttribute <- s.ownedAttribute,
        representation <- s.representation,
        classifierBehavior <- s.classifierBehavior,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
}

rule DecisionNode {
    from s : UML2!DecisionNode
    to t : UML2!DecisionNode mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        redefinedElement <- s.redefinedElement,
        decisionInput <- s.decisionInput,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule DurationInterval {
    from s : UML2!DurationInterval
    to t : UML2!DurationInterval mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        min <- s.min,
        max <- s.max,
        type <- s.type,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule TemplateParameterSubstitution {
    from s : UML2!TemplateParameterSubstitution
    to t : UML2!TemplateParameterSubstitution mapsTo s (
        eAnnotations <- s.eAnnotations,
        formal <- s.formal,
        actual <- s.actual,
        ownedComment <- s.ownedComment,
        ownedActual <- s.ownedActual)
}

rule ReadLinkAction {
    from s : UML2!ReadLinkAction
    to t : UML2!ReadLinkAction mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        isLeaf <- s.isLeaf,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        handler <- s.handler,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        localPostcondition <- s.localPostcondition,
        redefinedElement <- s.redefinedElement,
        endData <- s.endData,
        result <- s.result,
        localPrecondition <- s.localPrecondition,
        ownedComment <- s.ownedComment,
        nameExpression <- s.nameExpression)
}

rule ProfileApplication {
    from s : UML2!ProfileApplication
    to t : UML2!ProfileApplication mapsTo s (
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        importedProfile <- s.importedProfile,
        ownedComment <- s.ownedComment,
        importedPackage <- s.importedPackage)
}

