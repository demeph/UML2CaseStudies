-- $Id$
-- Implements the Observer profile.
module UML2Observer; --extends UML2Copy

create OUT : UML2 from IN : UML2, OBSERVER : UML2, UML2TYPES : UML2;

uses Strings;
uses UML2;
uses Mappings;

-- ======================================================================
-- model-specific helpers begin
-- ======================================================================

helper def : Observer : UML2!uml::Interface = 'observer::Observer'->interface();
helper def : oclString : UML2!uml::PrimitiveType = 'String'->primitiveType();
helper def : oclAny : UML2!uml::PrimitiveType = 'OclAny'->primitiveType();

helper context UML2!uml::Classifier def : isObservable() : Boolean =
	UML2!Observer::Observable->allInstances()->select(o|o.base_Classifier=self)->notEmpty();

helper context UML2!uml::Classifier def : isObserver() : Boolean =
	UML2!Observer::Observer->allInstances()->select(o|o.base_Classifier=self)->notEmpty();

helper context UML2!uml::Association def : isSubscribe() : Boolean =
	UML2!Observer::subscribe->allInstances()->select(s|s.base_Association=self)->notEmpty();

helper context UML2!uml::Dependency def : isAccessor() : Boolean =
	UML2!Accessors::accessor->allInstances()->select(a|a.base_Dependency=self)->notEmpty();

helper context UML2!uml::Property def : notifyObservers() : String =
	self.type->qualifiedName('separator'->value())->notifyObserversBody();

helper context UML2!uml::Class def : update() : String =
	self->handlers()->iterate(o; acc : String = ''|acc + o->update());

helper context UML2!uml::Class def : handlers() : Sequence(UML2!uml::Operation) =
	self.ownedOperation->select(o|
		o.name->startsWith('on') and 
		o.name->endsWith('Change') and 
		o.name->size() > 8);

helper context UML2!uml::Operation def : update() : String =
	self.name->updateBody(self->propertyName(), self->parTypeName());

helper context UML2!uml::Operation def : propertyName() : String =
	self.name->substring(3, self.name->size() - 6); -- onPropertyChange -> Property

helper context UML2!uml::Operation def : parTypeName() : String =
	self.ownedParameter->first().type->qualifiedName('separator'->value());

helper context UML2!uml::Behavior def : isPlainMethod() : Boolean =
	if self.specification->isAccessor() then
		if self.owner->isObservableKind() then
			false
		else if self.owner->isObserverKind() and self.specification->isSubscriber() then
			false
		else
			true
		endif endif
	else
		true
	endif;

helper context UML2!uml::Behavior def : isNotifyMethod() : Boolean =
	if self.specification->isAccessor() then
		if not self.owner->isObservableKind() then
			false
		else if self.owner->isObserverKind() and self.specification->isSubscriber() then
			false
		else
			true
		endif endif
	else
		false
	endif;
	
helper context UML2!uml::Behavior def : isNotifySubscribeMethod() : Boolean =
	if self.specification->isAccessor() then
		if not self.owner->isObservableKind() then
			false
		else if self.owner->isObserverKind() and self.specification->isSubscriber() then
			true
		else
			false
		endif endif
	else
		false
	endif;
	
helper context UML2!uml::Behavior def : isSubscribeMethod() : Boolean =
	if self.specification->isAccessor() then
		if self.owner->isObservableKind() then
			false
		else if self.owner->isObserverKind() and self.specification->isSubscriber() then
			true
		else
			false
		endif endif
	else
		false
	endif;

helper context UML2!uml::Operation def : isAccessor() : Boolean =
	self.clientDependency->select(d|d->isAccessor())->notEmpty();

helper context UML2!uml::Classifier def : isObservableKind() : Boolean =
	if self->isObservable() then
		true
	else
		not self.generalization->select(g|g.general->isObservableKind())->isEmpty()
	endif;

helper context UML2!uml::Classifier def : isObserverKind() : Boolean =
	if self->isObserver() then
		true
	else
		not self.generalization->select(g|g.general->isObserverKind())->isEmpty()
	endif;

helper context UML2!uml::Operation def : isSubscriber() : Boolean =
	if self->isAccessor() then
		self->accessorFor()->hasSubscribesAssociation()
	else
		false
	endif;

helper context UML2!uml::Operation def : accessorFor() : UML2!uml::Property =
	self->accessorDependency().supplier->select(p|
		p.oclIsKindOf(UML2!uml::Property))->first();

helper context UML2!uml::Operation def : accessorDependency() : UML2!uml::Dependency =
	self.clientDependency->select(d|d->isAccessor())->first();

helper context UML2!uml::Property def : hasSubscribesAssociation() : Boolean =
	if self.association->oclIsUndefined() then
		false
	else
		self.association->isSubscribe()
	endif;

helper context UML2!uml::Operation def : notify(body : String) : String =
	if self.name->startsWith('remove') then
		self->accessorFor()->removerNotify(body)
	else if self.name->startsWith('add') or self.name->startsWith('insert') then
		self->accessorFor()->adderNotify(body)
	else if self.name->startsWith('set') then
		self->accessorFor()->setterNotify(body)
	else
		body
	endif endif endif;

helper context UML2!uml::Property def : setterNotify(body : String) : String =
	self.name->setterNotifyBody(
		self.type->qualifiedName('separator'->value()), body);
	
helper context UML2!uml::Property def : adderNotify(body : String) : String =
	self.name->adderNotifyBody(
		self.type->qualifiedName('separator'->value()), body);
	
helper context UML2!uml::Property def : removerNotify(body : String) : String =
	self.name->removerNotifyBody(
		self.type->qualifiedName('separator'->value()), body);

helper context UML2!uml::Operation def : subscribe(body : String) : String =
	if self.name->startsWith('remove') then
		self->accessorFor().name->removerSubscribeBody(body)
	else if self.name->startsWith('add') or self.name->startsWith('insert') then
		self->accessorFor().name->adderSubscribeBody(body)
	else if self.name->startsWith('set') then
		self->accessorFor().name->setterSubscribeBody(body)
	else
		body
	endif endif endif;

-- ======================================================================
-- model-specific helpers end
-- ======================================================================

-- ======================================================================
-- transformation rules begin
-- ======================================================================

rule Class {
    from s : UML2!uml::Class (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!uml::Class) and
			not s->isObservable() and
			not s->isObserver()
		else false endif)
    to t : UML2!uml::Class mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception)
}
	
rule ObservableClass {
    from s : UML2!uml::Class (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!uml::Class) and
			s->isObservable() and
			not s->isObserver()
		else false endif)
    to t : UML2!uml::Class mapsTo s (
        name <- s.name->debug('ObservableClass'),
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute->union(Set{observers}),
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior->union(Set{getBehavior, addBehavior, removeBehavior, notifyBehavior}),
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception),
	-- Observable functionality --
	   observers : UML2!uml::Property (
	   	name <- 'observer',
		type <- thisModule.Observer,
		visibility <- #private,
		isUnique <- true,
		isOrdered <- true,
		upperValue <- observersUpper,
		lowerValue <- observersLower),
	   observersUpper : UML2!uml::LiteralUnlimitedNatural (
	   	value <- 0-1),
	   observersLower : UML2!uml::LiteralInteger (
	   	value <- 0),
	-- Get --
		getOp : UML2!uml::Operation (
	   	name <- 'getObservers',
		class <- s,
		visibility <- #public,
		ownedParameter <- Sequence{getPar},
		concurrency <- #sequential),
	   getPar : UML2!uml::Parameter (
	   	name <- 'return',
        lowerValue <- getParLow,
        upperValue <- getParUp,
		type <- observers.type,
		effect <- #read,
		direction <- #return),
	   getParLow : UML2!uml::LiteralInteger (
	   	value <- 0),
	   getParUp : UML2!uml::LiteralUnlimitedNatural (
	   	value <- 0-1),
	   getBehavior : UML2!uml::OpaqueBehavior (
	   	specification <- getOp,
		name <- getOp.name + 'Behavior',
		language <- Sequence{'language'->value()},
		body <- Sequence{observers.name->multiGetterBody()}),
	-- Add --
	   addOp : UML2!uml::Operation (
	   	name <- 'addObserver',
		class <- s,
		visibility <- #public,
		ownedParameter <- Sequence{addPar},
		concurrency <- #sequential),
	   addPar : UML2!uml::Parameter (
	   	name <- observers.name,
		type <- observers.type,
		effect <- #update,
		direction <- #"in"),
	   addBehavior : UML2!uml::OpaqueBehavior (
	   	specification <- addOp,
		name <- addOp.name + 'Behavior',
		language <- Sequence{'language'->value()},
		body <- Sequence{observers.name->adderBody(observers.isUnique)}),
	-- Remove --
	   removeOp : UML2!uml::Operation (
	   	name <- 'removeObserver',
		class <- s,
		visibility <- #public,
		ownedParameter <- Sequence{removePar},
		concurrency <- #sequential),
	   removePar : UML2!uml::Parameter (
	   	name <- observers.name,
		type <- observers.type,
		effect <- #update,
		direction <- #"in"),
	   removeBehavior : UML2!uml::OpaqueBehavior (
	   	specification <- removeOp,
		name <- removeOp.name + 'Behavior',
		language <- Sequence{'language'->value()},
		body <- Sequence{observers.name->removerBody()}),
	-- Notify --
	   notifyOp : UML2!uml::Operation (
	   	name <- 'notifyObservers',
		class <- s,
		visibility <- #public,
		ownedParameter <- Sequence{notifyPar1, notifyPar2},
		concurrency <- #sequential),
	   notifyPar1 : UML2!uml::Parameter (
	   	name <- 'name',
		type <- thisModule.oclString,
		effect <- #read,
		direction <- #"in"),
	   notifyPar2 : UML2!uml::Parameter (
	   	name <- 'value',
		type <- thisModule.oclAny,
		effect <- #update,
		direction <- #"in"),
	   notifyBehavior : UML2!uml::OpaqueBehavior (
		specification <- notifyOp,
		name <- notifyOp.name + 'Behavior',
		language <- Sequence{'language'->value()},
		body <- Sequence{observers->notifyObservers()})
}

rule ObserverClass {
    from s : UML2!uml::Class (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!uml::Class) and
			not s->isObservable() and
			s->isObserver()
		else false endif)
	to t : UML2!uml::Class mapsTo s (
        name <- s.name->debug('ObserverClass'),
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior->union(Set{updateBehavior}),
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization->union(Set{real}),
		ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception),
	-- Observer functionality --
	   real : UML2!uml::InterfaceRealization (
	   	contract <- thisModule.Observer,
		implementingClassifier <- s,
		client <- Set{s}),
	-- Update --
	   updateOp : UML2!uml::Operation (
	   	name <- 'update',
		class <- s,
		visibility <- #public,
		ownedParameter <- Sequence{updatePar1, updatePar2},
		concurrency <- #sequential),
	   updatePar1 : UML2!uml::Parameter (
	   	name <- 'name',
		type <- thisModule.oclString,
		effect <- #read,
		direction <- #"in"),
	   updatePar2 : UML2!uml::Parameter (
	   	name <- 'value',
		type <- thisModule.oclAny,
		effect <- #update,
		direction <- #"in"),
	   updateBehavior : UML2!uml::OpaqueBehavior (
		specification <- updateOp,
		name <- updateOp.name + 'Behavior',
		language <- Sequence{'language'->value()},
		body <- Sequence{s->update()})
}

rule ObservableObserverClass {
    from s : UML2!uml::Class (
		if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!uml::Class) and
			s->isObservable() and
			s->isObserver()
		else false endif)
    to t : UML2!uml::Class mapsTo s (
        name <- s.name->debug('ObservableObserverClass'),
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute->union(Set{observers}),
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior->union(Set{getBehavior, addBehavior, removeBehavior, notifyBehavior, updateBehavior}),
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization->union(Set{real}),
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception),
	-- Observable functionality --
	   observers : UML2!uml::Property (
	   	name <- 'observers',
		type <- thisModule.Observer,
		visibility <- #private,
		isUnique <- true,
		isOrdered <- true,
		upperValue <- observersUpper,
		lowerValue <- observersLower),
	   observersUpper : UML2!uml::LiteralUnlimitedNatural (
	   	value <- 0-1),
	   observersLower : UML2!uml::LiteralInteger (
	   	value <- 0),
	-- Get --
		getOp : UML2!uml::Operation (
	   	name <- 'getObservers',
		class <- s,
		visibility <- #public,
		ownedParameter <- Sequence{getPar},
		concurrency <- #sequential),
	   getPar : UML2!uml::Parameter (
	   	name <- 'return',
        lowerValue <- getParLow,
        upperValue <- getParUp,
		type <- observers.type,
		effect <- #read,
		direction <- #return),
	   getParLow : UML2!uml::LiteralInteger (
	   	value <- 0),
	   getParUp : UML2!uml::LiteralUnlimitedNatural (
	   	value <- 0-1),
	   getBehavior : UML2!uml::OpaqueBehavior (
	   	specification <- getOp,
		name <- getOp.name + 'Behavior',
		language <- Sequence{'language'->value()},
		body <- Sequence{observers.name->multiGetterBody()}),
	-- Add --
	   addOp : UML2!uml::Operation (
	   	name <- 'addObserver',
		class <- s,
		visibility <- #public,
		ownedParameter <- Sequence{addPar},
		concurrency <- #sequential),
	   addPar : UML2!uml::Parameter (
	   	name <- s.name,
		type <- observers.type,
		effect <- #update,
		direction <- #"in"),
	   addBehavior : UML2!uml::OpaqueBehavior (
	   	specification <- addOp,
		name <- addOp.name + 'Behavior',
		language <- Sequence{'language'->value()},
		body <- Sequence{observers.name->adderBody(observers.isUnique)}),
	-- Remove --
	   removeOp : UML2!uml::Operation (
	   	name <- 'removeObserver',
		class <- s,
		visibility <- #public,
		ownedParameter <- Sequence{removePar},
		concurrency <- #sequential),
	   removePar : UML2!uml::Parameter (
	   	name <- s.name,
		type <- observers.type,
		effect <- #update,
		direction <- #"in"),
	   removeBehavior : UML2!uml::OpaqueBehavior (
	   	specification <- removeOp,
		name <- removeOp.name + 'Behavior',
		language <- Sequence{'language'->value()},
		body <- Sequence{observers.name->removerBody()}),
	-- Notify --
	   notifyOp : UML2!uml::Operation (
	   	name <- 'notifyObservers',
		class <- s,
		visibility <- #public,
		ownedParameter <- Sequence{notifyPar1, notifyPar2},
		concurrency <- #sequential),
	   notifyPar1 : UML2!uml::Parameter (
	   	name <- 'name',
		type <- thisModule.oclString,
		effect <- #read,
		direction <- #"in"),
	   notifyPar2 : UML2!uml::Parameter (
	   	name <- 'value',
		type <- thisModule.oclAny,
		effect <- #update,
		direction <- #"in"),
	   notifyBehavior : UML2!uml::OpaqueBehavior (
		specification <- notifyOp,
		name <- notifyOp.name + 'Behavior',
		language <- Sequence{'language'->value()},
		body <- Sequence{observers->notifyObservers()}),
	-- Observer functionality --
	   real : UML2!uml::InterfaceRealization (
	   	contract <- thisModule.Observer,
		implementingClassifier <- s,
		client <- Set{s}),
	-- Update --
	   updateOp : UML2!uml::Operation (
	   	name <- 'update',
		class <- s,
		visibility <- #public,
		ownedParameter <- Sequence{updatePar1, updatePar2},
		concurrency <- #sequential),
	   updatePar1 : UML2!uml::Parameter (
	   	name <- 'name',
		type <- thisModule.oclString,
		effect <- #read,
		direction <- #"in"),
	   updatePar2 : UML2!uml::Parameter (
	   	name <- 'value',
		type <- thisModule.oclAny,
		effect <- #update,
		direction <- #"in"),
	   updateBehavior : UML2!uml::OpaqueBehavior (
		specification <- updateOp,
		name <- updateOp.name + 'Behavior',
		language <- Sequence{'language'->value()},
		body <- Sequence{s->update()})
}

rule OpaqueBehavior {
    from s : UML2!uml::OpaqueBehavior (
    	if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!uml::OpaqueBehavior) and
			s->isPlainMethod()
		else false endif)
    to t : UML2!uml::OpaqueBehavior mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        body <- s.body,
        language <- s.language,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification)
}

rule NotifyOpaqueBehavior {
    from s : UML2!uml::OpaqueBehavior (
    	if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!uml::OpaqueBehavior) and
			s->isNotifyMethod()
		else false endif)
    to t : UML2!uml::OpaqueBehavior mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        body <- s.body->collect(b|s.specification->notify(b)),  --Sequence{s.specification->notify(s.body->first())},
        language <- s.language,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification)
}

rule SubscribeOpaqueBehavior {
    from s : UML2!uml::OpaqueBehavior (
    	if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!uml::OpaqueBehavior) and
			s->isSubscribeMethod()
		else false endif)
    to t : UML2!uml::OpaqueBehavior mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        body <- s.body->collect(b|s.specification->subscribe(b)),  --Sequence{s.specification->subscribe(s.body->first())},
        language <- s.language,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification)
}

rule NotifySubscribeOpaqueBehavior {
    from s : UML2!uml::OpaqueBehavior (
    	if thisModule.inElements->includes(s) then
			s->oclIsTypeOf(UML2!uml::OpaqueBehavior) and
			s->isNotifySubscribeMethod()
		else false endif)
    to t : UML2!uml::OpaqueBehavior mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        body <- s.body->collect(b|s.specification->notify(
        	s.specification->subscribe(b))),  --Sequence{s.specification->notify(
        	--s.specification->subscribe(s.body->first()))},
        language <- s.language,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification)
}

-- ======================================================================
-- transformation rules end
-- ======================================================================
