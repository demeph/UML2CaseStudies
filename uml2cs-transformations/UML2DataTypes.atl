-- $Id$
-- Transforms all UML2-specific data types to programming language types.
--
-- Known issues:
-- * "Allow inter-model references" causes unexpected deep copy.
--   This is currently leveraged by this transformation, which uses
--   nor explicit copying rules, neither refinement mode.
--
module UML2DataTypes;

create OUT : UML2 from IN : UML2, JAVATYPES : UML2;

uses Strings;
uses UML2;
uses Mappings;

-- ======================================================================
-- model-specific helpers begin
-- ======================================================================

helper def : inElements : Set(UML2!Element) = UML2!Element->allInstancesFrom('IN');

helper context UML2!PrimitiveType def : implType() : UML2!Type =
	self.name->implTypeName()->type();

helper context UML2!Type def : implType() : UML2!Type =
	self;

helper context UML2!TypedElement def : implType() : UML2!Type =
	self.type->implType();

helper context UML2!StructuralFeature def : implType() : UML2!Type =
	if self->isSingle() then
		self.type->implType()
	else
		self->implCollectionType()
	endif;

helper context UML2!Parameter def : implType() : UML2!Type =
	if self->isSingle() then
		self.type->implType()
	else if self.direction = #return then
		self.type.name->implCollectionReturnTypeName()->type()
	else
		self->implCollectionType()
	endif endif;

helper context UML2!MultiplicityElement def : implCollectionType() : UML2!Type =
	if self.isOrdered then
		if self.isUnique then
			'OrderedSet'->implTypeName()->type()
		else
			'Sequence'->implTypeName()->type()
		endif
	else
		if self.isUnique then
			'Set'->implTypeName()->type()
		else
			'Bag'->implTypeName()->type()
		endif
	endif;

helper context UML2!TypedElement def : defaultValueBody() : String =
	self.type->defaultValueBody();

helper context UML2!StructuralFeature def : defaultValueBody() : String =
	if self->isSingle() then
		self->implType()->defaultValueBody()
	else
		self->implCollectionType()->defaultValueBody()
	endif;

helper context UML2!Type def : defaultValueBody() : String =
	self->umlQualifiedName()->defaultValueBody();

-- ======================================================================
-- model-specific helpers end
-- ======================================================================
	
-- ======================================================================
-- transformation rules begin
-- ======================================================================

rule Model {
    from s : UML2!Model (thisModule.inElements->includes(s))
    to t : UML2!Model mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        packageableElement_visibility <- s.packageableElement_visibility,
        viewpoint <- s.viewpoint,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        ownedRule <- s.ownedRule,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        templateParameter <- s.templateParameter,
        ownedMember <- s.ownedMember,
        packageMerge <- s.packageMerge,
        appliedProfile <- s.appliedProfile,
        packageExtension <- s.packageExtension)
}

rule Property {
    from s : UML2!Property (
    	if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(UML2!Property)
		else false endif)
    to defVal : UML2!OpaqueExpression (
	   	language <- 'language'->value(),
		body <- s->defaultValueBody())
	do {
		s.type <- s->implType();
		s.defaultValue <-
			if s.defaultValue->oclIsUndefined() then defVal
			else s.defaultValue endif;
	}
}

rule Parameter {
    from s : UML2!Parameter (thisModule.inElements->includes(s))
	do {
		s.type <- s->implType();
	}
}

rule VoidOperation {
    from s : UML2!Operation (
    	if thisModule.inElements->includes(s) then
			s.parameter->select(p|p.direction = #return)->isEmpty()
		else false endif)
    to retPar : UML2!Parameter (
	   	name <- 'return',
        lowerValue <- retParLow,
        upperValue <- retParUp,
		type <- 'OclVoid'->implTypeName()->type(),
		effect <- #read,
		direction <- #return),
	   retParLow : UML2!LiteralInteger (
	   	value <- 1),
	   retParUp : UML2!LiteralUnlimitedNatural (
	   	value <- 1)
	do {
		retPar.operation <- s;
	}
}

-- ======================================================================
-- transformation rules end
-- ======================================================================
