-- $Id$
-- Introduces accessor operations for all public properties
--
-- Known issues:
-- * "Allow inter-model references" causes unexpected deep copy.
--   This is currently leveraged by this transformation, which uses
--   nor explicit copying rules, neither refinement mode.
-- * Current UML2 standard does not allow PackageableElements
--   to set their package. Only Package can set its ownedMembers.
--   This issue is solved using a small imperative "do" block.
--
module UML2Accessors;

create OUT : UML2 from IN : UML2, ACCESSORS : UML2;

uses Strings;
uses UML2;
uses Mappings;

-- ======================================================================
-- model-specific helpers begin
-- ======================================================================

helper def : inElements : Set(UML2!Element) = UML2!Element->allInstancesFrom('IN');
helper def : accessorsProfile : UML2!Profile = 'Accessors'->profile();
helper def : accessor : UML2!Stereotype = 'accessor'->stereotype();
helper def : oclInteger : UML2!PrimitiveType = 'Integer'->primitiveType();

helper context UML2!Property def : setter() : String =
	if self.hasAssociatedProperty() then
		self.dualSetter()
	else
		self.name.setterBody()
	endif;

helper context UML2!Property def : dualSetter() : String =
	if self.associatedProperty().isSingle() then
		self.name.dualSetterBody(self.associatedProperty().name.firstToUpper())
	else
		self.name.addRemoveSetterBody(self.associatedProperty().name.firstToUpper())
	endif;
	
helper context UML2!Property def : adder() : String =
	if self.hasAssociatedProperty() then
		self.dualAdder()
	else
		self.name.adderBody()
	endif;

helper context UML2!Property def : dualAdder() : String =
	if self.associatedProperty().isSingle() then
		self.name.setterAdderBody(self.associatedProperty().name.firstToUpper())
	else
		self.name.dualAdderBody(self.associatedProperty().name.firstToUpper())
	endif;
	
helper context UML2!Property def : insert() : String =
	if self.hasAssociatedProperty() then
		self.dualInsert()
	else
		self.name.insertBody()
	endif;

helper context UML2!Property def : dualInsert() : String =
	if self.associatedProperty().isSingle() then
		self.name.setterInsertBody(self.associatedProperty().name.firstToUpper())
	else
		self.name.dualInsertBody(self.associatedProperty().name.firstToUpper())
	endif;
	
helper context UML2!Property def : remover() : String =
	if self.hasAssociatedProperty() then
		self.dualRemover()
	else
		self.name.removerBody()
	endif;

helper context UML2!Property def : dualRemover() : String =
	if self.associatedProperty().isSingle() then
		self.name.setterRemoverBody(self.associatedProperty().name.firstToUpper())
	else
		self.name.dualRemoverBody(self.associatedProperty().name.firstToUpper())
	endif;

-- ======================================================================
-- model-specific helpers end
-- ======================================================================
	
-- ======================================================================
-- transformation rules begin
-- ======================================================================

rule ModelProfileApplication {
	from s : UML2!Model (
		thisModule.inElements->includes(s))
    to t : UML2!Model mapsTo s (
        visibility <- s.visibility,
        name <- s.name,
        viewpoint <- s.viewpoint,
        packageableElement_visibility <- s.packageableElement_visibility,
        eAnnotations <- s.eAnnotations,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        ownedMember <- s.ownedMember,
        appliedProfile <- s.appliedProfile,
        packageExtension <- s.packageExtension,
        ownedRule <- s.ownedRule,
        packageMerge <- s.packageMerge,
        elementImport <- s.elementImport,
        ownedComment <- s.ownedComment,
        packageImport <- s.packageImport,
        nameExpression <- s.nameExpression)
	do {
		if not s.includesProfile(thisModule.accessorsProfile) then
			t.apply(thisModule.accessorsProfile)
		else true endif;
	}
}

rule PublicPropertySingle {
	from s : UML2!Property (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(UML2!Property) and
			(s.visibility = #public) and 
			s.isNavigable() and
			s.isSingle()
		else false endif)
	using { vis : UML2!VisibilityKind =
				if s.visibility = #public then #private else s.visibility endif;
			baseNameS : String = s.accessorBaseNameS();
			p : UML2!Package = s.class_->owningPackage(); }
	to
	-- Get --
		getOp : UML2!Operation (
	   	name <- 'get' + baseNameS,
		class_ <- s.class_,
		visibility <- s.visibility,
		isStatic <- s.isStatic,
		isAbstract <- false,
		concurrency <- #sequential),
	   getPar : UML2!Parameter (
	   	name <- 'return',
		operation <- getOp,
        lowerValue <- getParLow,
        upperValue <- getParUp,
		type <- s.type,
		effect <- #read,
		direction <- #return),
	   getParLow : UML2!LiteralInteger (
	   	value <- s.lower()),
	   getParUp : UML2!LiteralUnlimitedNatural (
	   	value <- s.upper()),
	   getBehavior : UML2!Activity (
	   	"context" <- s.class_,
	   	specification <- getOp,
	   	language <- 'language'.value(),
		body <- s.name.getterBody()),
	   getDep : UML2!Dependency (
	   	name <- 'accessor ' + 'get' + baseNameS + '()',
		client <- getOp,
		supplier <- s),
	-- Set --
	   setOp : UML2!Operation (
	   	name <- 'set' + baseNameS,
		class_ <- s.class_,
		visibility <- s.visibility,
		isStatic <- s.isStatic,
		isAbstract <- false,
		concurrency <- #sequential),
	   setPar : UML2!Parameter (
	   	name <- s.name,
		operation <- setOp,
        lowerValue <- setParLow,
        upperValue <- setParUp,
		type <- s.type,
		effect <- #update,
		direction <- #"in"),
	   setParLow : UML2!LiteralInteger (
	   	value <- s.lower()),
	   setParUp : UML2!LiteralUnlimitedNatural (
	   	value <- s.upper()),
	   setBehavior : UML2!Activity (
	   	"context" <- s.class_,
	   	specification <- setOp,
	   	language <- 'language'.value(),
		body <- s.setter()),
	   setDep : UML2!Dependency (
	   	name <- 'accessor ' + 'set' + baseNameS + '()',
		client <- setOp,
		supplier <- s)
	do {
		p.ownedMember <- p.ownedMember->union(Set{getDep, setDep});
		getDep.apply(thisModule.accessor);
		setDep.apply(thisModule.accessor);
	}
}

rule PublicPropertyCollection {
	from s : UML2!Property (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(UML2!Property) and
			(s.visibility = #public) and 
			s.isNavigable() and
			not s.isSingle() and 
			not s.isOrdered
		else false endif)
	using { vis : UML2!VisibilityKind =
				if s.visibility = #public then #private else s.visibility endif;
			baseNameS : String = s.accessorBaseNameS();
			baseName : String = s.accessorBaseName();
			p : UML2!Package = s.class_->owningPackage(); }
	to 
	-- Get --
		getOp : UML2!Operation (
	   	name <- 'get' + baseNameS,
		class_ <- s.class_,
		visibility <- s.visibility,
		isStatic <- s.isStatic,
		isAbstract <- false,
		concurrency <- #sequential),
	   getPar : UML2!Parameter (
	   	name <- 'return',
		operation <- getOp,
        lowerValue <- getParLow,
        upperValue <- getParUp,
		type <- s.type,
		effect <- #read,
		direction <- #return),
	   getParLow : UML2!LiteralInteger (
	   	value <- s.lower()),
	   getParUp : UML2!LiteralUnlimitedNatural (
	   	value <- s.upper()),
	   getBehavior : UML2!Activity (
	   	"context" <- s.class_,
	   	specification <- getOp,
	   	language <- 'language'.value(),
		body <- s.name.getterBody()),
	   getDep : UML2!Dependency (
	   	name <- 'accessor ' + 'get' + baseNameS + '()',
		client <- getOp,
		supplier <- s),
	-- Add --
	   addOp : UML2!Operation (
	   	name <- 'add' + baseName,
		class_ <- s.class_,
		visibility <- s.visibility,
		isStatic <- s.isStatic,
		isAbstract <- false,
		concurrency <- #sequential),
	   addPar : UML2!Parameter (
	   	name <- s.name,
		operation <- addOp,
        lowerValue <- addParLow,
        upperValue <- addParUp,
		type <- s.type,
		effect <- #update,
		direction <- #"in"),
	   addParLow : UML2!LiteralInteger (
	   	value <- 1),
	   addParUp : UML2!LiteralUnlimitedNatural (
	   	value <- (0-1)),
	   addBehavior : UML2!Activity (
	   	"context" <- s.class_,
	   	specification <- addOp,
	   	language <- 'language'.value(),
		body <- s.adder()),
	   addDep : UML2!Dependency (
	   	name <- 'accessor ' + 'add' + baseName + '()',
		client <- addOp,
		supplier <- s),
	-- Remove --
	   removeOp : UML2!Operation (
	   	name <- 'remove' + baseName,
		class_ <- s.class_,
		visibility <- s.visibility,
		isStatic <- s.isStatic,
		isAbstract <- false,
		concurrency <- #sequential),
	   removePar : UML2!Parameter (
	   	name <- s.name,
		operation <- removeOp,
        lowerValue <- removeParLow,
        upperValue <- removeParUp,
		type <- s.type,
		effect <- #update,
		direction <- #"in"),
	   removeParLow : UML2!LiteralInteger (
	   	value <- 1),
	   removeParUp : UML2!LiteralUnlimitedNatural (
	   	value <- (0-1)),
	   removeBehavior : UML2!Activity (
	   	"context" <- s.class_,
	   	specification <- removeOp,
	   	language <- 'language'.value(),
		body <- s.remover()),
	   removeDep : UML2!Dependency (
	   	name <- 'accessor ' + 'remove' + baseName + '()',
		client <- removeOp,
		supplier <- s)
	do {
		p.ownedMember <- p.ownedMember->union(Set{getDep, addDep, removeDep});
		getDep->apply(thisModule.accessor);		
		addDep->apply(thisModule.accessor);		
		removeDep->apply(thisModule.accessor);		
	}
}

rule PublicPropertySequence {
	from s : UML2!Property (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(UML2!Property) and
			(s.visibility = #public) and 
			s.isNavigable() and
			not s.isSingle() and 
			s.isOrdered
		else false endif)
	using { vis : UML2!VisibilityKind =
				if s.visibility = #public then #private else s.visibility endif;
			baseNameS : String = s.accessorBaseNameS();
			baseName : String = s.accessorBaseName();
			p : UML2!Package = s.class_->owningPackage(); }
	to 
	-- Get --
		getOp : UML2!Operation (
	   	name <- 'get' + baseNameS,
		class_ <- s.class_,
		visibility <- s.visibility,
		isStatic <- s.isStatic,
		isAbstract <- false,
		concurrency <- #sequential),
	   getPar : UML2!Parameter (
	   	name <- 'return',
		operation <- getOp,
        lowerValue <- getParLow,
        upperValue <- getParUp,
		type <- s.type,
		effect <- #read,
		kind <- #return),
	   getParLow : UML2!LiteralInteger (
	   	value <- s.lower()),
	   getParUp : UML2!LiteralUnlimitedNatural (
	   	value <- s.upper()),
	   getBehavior : UML2!Activity (
	   	"context" <- s.class_,
	   	specification <- getOp,
	   	language <- 'language'.value(),
		body <- s.name.getterBody()),
	   getDep : UML2!Dependency (
	   	name <- 'accessor ' + 'get' + baseNameS + '()',
		client <- getOp,
		supplier <- s),
	-- Add --
	   addOp : UML2!Operation (
	   	name <- 'add' + baseName,
		class_ <- s.class_,
		visibility <- s.visibility,
		isStatic <- s.isStatic,
		isAbstract <- false,
		concurrency <- #sequential),
	   addPar : UML2!Parameter (
	   	name <- s.name,
		operation <- addOp,
        lowerValue <- addParLow,
        upperValue <- addParUp,
		type <- s.type,
		effect <- #update,
		direction <- #"in"),
	   addParLow : UML2!LiteralInteger (
	   	value <- 1),
	   addParUp : UML2!LiteralUnlimitedNatural (
	   	value <- (0-1)),
	   addBehavior : UML2!Activity (
	   	"context" <- s.class_,
	   	specification <- addOp,
	   	language <- 'language'.value(),
		body <- s.adder()),
	   addDep : UML2!Dependency (
	   	name <- 'accessor ' + 'add' + baseName + '()',
		client <- addOp,
		supplier <- s),
	-- Remove --
	   removeOp : UML2!Operation (
	   	name <- 'remove' + baseName,
		class_ <- s.class_,
		visibility <- s.visibility,
		isStatic <- s.isStatic,
		isAbstract <- false,
		concurrency <- #sequential),
	   removePar : UML2!Parameter (
	   	name <- s.name,
		operation <- removeOp,
        lowerValue <- removeParLow,
        upperValue <- removeParUp,
		type <- s.type,
		effect <- #update,
		direction <- #"in"),
	   removeParLow : UML2!LiteralInteger (
	   	value <- 1),
	   removeParUp : UML2!LiteralUnlimitedNatural (
	   	value <- (0-1)),
	   removeBehavior : UML2!Activity (
	   	"context" <- s.class_,
	   	specification <- removeOp,
	   	language <- 'language'.value(),
		body <- s.remover()),
	   removeDep : UML2!Dependency (
	   	name <- 'accessor ' + 'remove' + baseName + '()',
		client <- removeOp,
		supplier <- s),
	-- GetAt --
	   getAtOp : UML2!Operation (
	   	name <- 'get' + baseName + 'At',
		class_ <- s.class_,
		visibility <- s.visibility,
		isStatic <- s.isStatic,
		isAbstract <- false,
		concurrency <- #sequential),
	   getAtPar1 : UML2!Parameter (
	   	name <- 'index',
		operation <- getAtOp,
        lowerValue <- getAtPar1Low,
        upperValue <- getAtPar1Up,
		type <- thisModule.oclInteger,
		effect <- #read,
		direction <- #"in"),
	   getAtPar1Low : UML2!LiteralInteger (
	   	value <- 1),
	   getAtPar1Up : UML2!LiteralUnlimitedNumeral (
	   	value <- 1),
	   getAtPar2 : UML2!Parameter (
	   	name <- 'return',
		operation <- getAtOp,
        lowerValue <- getAtPar2Low,
        upperValue <- getAtPar2Up,
		type <- s.type,
		effect <- #read,
		direction <- #"return"),
	   getAtPar2Low : UML2!LiteralInteger (
	   	value <- 1),
	   getAtPar2Up : UML2!LiteralUnlimitedNumeral (
	   	value <- (0-1)),
	   getAtBehavior : UML2!Activity (
	   	"context" <- s.class_,
	   	specification <- getAtOp,
	   	language <- 'language'.value(),
		body <- s.name.javaGetAt(s.type.qName())),
	   getAtDep : UML2!Dependency (
	   	name <- 'accessor ' + 'get' + baseName + 'At()',
		client <- getAtOp,
		supplier <- s),
	-- Insert --
	   insertOp : UML2!Operation (
	   	name <- 'insert' + baseName,
		class_ <- s.class_,
		visibility <- s.visibility,
		isStatic <- s.isStatic,
		isAbstract <- false,
		concurrency <- #sequential),
	   insertPar1 : UML2!Parameter (
	   	name <- s.name,
		operation <- getAtOp,
        lowerValue <- insertPar1Low,
        upperValue <- insertPar1Up,
		type <- s.type,
		effect <- #update,
		direction <- #"in"),
	   insertPar1Low : UML2!LiteralInteger (
	   	value <- 1),
	   insertPar1Up : UML2!LiteralUnlimitedNumeral (
	   	value <- 1),
	   insertPar2 : UML2!Parameter (
	   	name <- 'index',
		operation <- insertOp,
        lowerValue <- insertPar2Low,
        upperValue <- insertPar2Up,
		type <- thisModule.oclInteger,
		effect <- #read,
		direction <- #"in"),
	   insertPar2Low : UML2!LiteralInteger (
	   	value <- 1),
	   insertPar2Up : UML2!LiteralUnlimitedNumeral (
	   	value <- 1),
	   insertActivity : UML2!Activity (
	   	"context" <- s.class_,
	   	specification <- insertOp,
	   	language <- 'language'.value(),
		body <- s.insert()),
	   insertDep : UML2!Dependency (
	   	name <- 'accessor ' + 'insert' + baseName + '()',
		client <- insertOp,
		supplier <- s)
	do {
		p.ownedMember <- p.ownedMember->union(Set{getDep, addDep, removeDep, getAtDep, insertDep});
		getDep->apply(thisModule.accessor);		
		addDep->apply(thisModule.accessor);		
		removeDep->apply(thisModule.accessor);		
		getAtDep->apply(thisModule.accessor);		
		insertDep->apply(thisModule.accessor);		
	}
}

-- ======================================================================
-- transformation rules end
-- ======================================================================
