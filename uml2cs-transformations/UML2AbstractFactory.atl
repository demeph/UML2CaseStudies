-- @atlcompiler atl2006
-- $Id$
-- Implements the AbstractFactory profile.
module UML2AbstractFactory; --extends UML2Copy

create OUT : UML2 from IN : UML2;

uses UML2Copy;
uses UML2;
uses Mappings;

-- ======================================================================
-- model-specific helpers begin
-- ======================================================================

helper def : language : String = 'language'.value();
helper def : abstractFactories : Sequence(UML2!"AbstractFactory::AbstractFactory") = UML2!"AbstractFactory::AbstractFactory".allInstances();
helper def : concreteFactories : Sequence(UML2!"AbstractFactory::ConcreteFactory") = UML2!"AbstractFactory::ConcreteFactory".allInstances();
helper def : products : Sequence(UML2!"AbstractFactory::product") = UML2!"AbstractFactory::product".allInstances();

helper context UML2!"uml::Classifier" def : isAbstractFactory : Boolean =
	thisModule.abstractFactories->select(a|a.base_Classifier=self)->notEmpty();

helper context UML2!"uml::Class" def : isConcreteFactory : Boolean =
	thisModule.concreteFactories->select(a|a.base_Class=self)->notEmpty();

helper context UML2!"uml::Dependency" def : isProduct : Boolean =
	thisModule.products->select(a|a.base_Dependency=self)->notEmpty();

-- ======================================================================
-- model-specific helpers end
-- ======================================================================

-- ======================================================================
-- transformation rules begin
-- ======================================================================

rule Class {
    from s : UML2!"uml::Class" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(UML2!"uml::Class") and
			not s.isConcreteFactory
		else false endif)
	using { myDependencies : Set(UML2!"uml::Dependency") = 
		s.clientDependency->select(d|
			d.oclIsTypeOf(UML2!"uml::Dependency") and d.isProduct); }
    to t : UML2!"uml::Class" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation
			->union(myDependencies->collect(d|
				thisModule.resolveTemp(d, 'createOp'))),
        ownedReception <- s.ownedReception)
}

rule ConcreteFactoryClass {
    from s : UML2!"uml::Class" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(UML2!"uml::Class") and
			s.isConcreteFactory
		else false endif)
	using { myDependencies : Set(UML2!"uml::Dependency") = 
		s.clientDependency->select(d|
			d.oclIsTypeOf(UML2!"uml::Dependency") and d.isProduct); }
    to t : UML2!"uml::Class" mapsTo s (
        name <- s.name->debug('ConcreteFactoryClass'),
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior
			->union(myDependencies->collect(d|
				thisModule.resolveTemp(d, 'createBehavior'))),
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation
			->union(myDependencies->collect(d|
				thisModule.resolveTemp(d, 'createOp'))),
        ownedReception <- s.ownedReception)
}

rule Interface {
    from s : UML2!"uml::Interface" (thisModule.inElements->includes(s))
	using { myDependencies : Set(UML2!"uml::Dependency") = 
		s.clientDependency->select(d|
			d.oclIsTypeOf(UML2!"uml::Dependency") and d.isProduct); }
	to t : UML2!"uml::Interface" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedOperation <- s.ownedOperation
			->union(myDependencies->collect(d|
				thisModule.resolveTemp(d, 'createOp'))),
        nestedClassifier <- s.nestedClassifier,
        redefinedInterface <- s.redefinedInterface,
        ownedReception <- s.ownedReception,
        protocol <- s.protocol)
}

rule Dependency {
    from s : UML2!"uml::Dependency" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(UML2!"uml::Dependency") and
			not s.isProduct
		else false endif)
    to t : UML2!"uml::Dependency" mapsTo s (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client)
}

rule AbstractProductDependency {
    from s : UML2!"uml::Dependency" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(UML2!"uml::Dependency") and
			if s.isProduct then
				s.client->select(c|c.isAbstractFactory)->notEmpty()
			else false endif
		else false endif)
	using { supplier : UML2!"uml::Classifier" = s.supplier->first(); }
    to t : UML2!"uml::Dependency" mapsTo s (
        name <- s.name.debug('AbstractProductDependency'),
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client),
	-- create
	   createOp : UML2!"uml::Operation" (
	   	name <- 'create' + supplier.name,
		visibility <- #public,
		ownedParameter <- Sequence{createPar},
		isAbstract <- true,
		concurrency <- #sequential),
	   createPar : UML2!"uml::Parameter" (
	   	name <- 'return',
		type <- supplier,
		effect <- #"create",
		direction <- #return)
}

rule ConcreteProductDependency {
    from s : UML2!"uml::Dependency" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(UML2!"uml::Dependency") and
			if s.isProduct then
				s.client->select(c|c.isConcreteFactory)->notEmpty()
			else false endif
		else false endif)
	using { superTypes : Set(UML2!"uml::Classifier") = s.client
    			->collect(c|c.superTypes)->flatten().debug('superTypes');
			clientDependencies : Set(UML2!"uml::Dependency") = superTypes
				->collect(c|c.clientDependency)->flatten().debug('clientDependencies');
			products : Set(UML2!"uml::Classifier") = clientDependencies
				->collect(d|d.supplier)->flatten().debug('products');
			supplier : UML2!"uml::Classifier" = s.supplier
				->collect(s|s.superTypes)->flatten().debug('supersuppliers')
				->select(c|products->includes(c))->first().debug('supplier'); }
    to t : UML2!"uml::Dependency" mapsTo s (
        name <- s.name->debug('ConcreteProductDependency'),
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client),
	-- create
	   createOp : UML2!"uml::Operation" (
	   	name <- 'create' + supplier.name.debug('supplier.name'),
		visibility <- #public,
		ownedParameter <- Sequence{createPar},
		concurrency <- #sequential),
	   createPar : UML2!"uml::Parameter" (
	   	name <- 'return',
		type <- supplier,
		effect <- #"create",
		direction <- #return),
	   createBehavior : UML2!"uml::OpaqueBehavior" (
	   	specification <- createOp,
		name <- createOp.name + 'Behavior',
		language <- Sequence{thisModule.language},
		body <- Sequence{s.supplier->first().name.createBody()})
}

-- ======================================================================
-- transformation rules end
-- ======================================================================
