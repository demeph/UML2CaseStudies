-- @atlcompiler emftvm
-- $Id$
-- Generates an ATL transformation that copies models using the given Ecore meta-model
query EModelCopyGenerator = ECORE!EClass.allInstancesFrom('IN')->iterate(e; acc : String = 
	'-- @atlcompiler emftvm\n' +
	'-- Generated by: $Id$\n' +
	'module EModelCopy;\n\n' +
	'create OUT : OUTMODEL from IN : INMODEL;\n\n' +
	'helper def : inElements : Set(INMODEL!"ecore::EObject") = INMODEL!"ecore::EObject".allInstancesFrom(\'IN\')->asSet();\n\n' +
	'helper context OclAny def : isInElement : Boolean =\n' +
	'	thisModule.inElements->includes(self);\n\n'|
	acc + e.toRuleString()).
	writeTo('EModelCopy.atl'.path);

uses "lib::Config";

helper context ECORE!EReference def : assignable : Boolean =
	not (self."derived" or self.container)
	and self.changeable;

helper context ECORE!EAttribute def : assignable : Boolean =
	not (self."derived") and self.changeable;

helper context ECORE!ENamedElement def : qName : String =
	self.name;

helper context ECORE!EClassifier def : qName : String =
	if self.ePackage.oclIsUndefined() then
		self.name
	else
		self.ePackage.qName + '::' + self.name
	endif;

helper context ECORE!EPackage def : qName : String =
	if self.eSuperPackage.oclIsUndefined() then
		self.name
	else
		self.eSuperPackage.qName + '::' + self.name
	endif;

helper context ECORE!ENamedElement def : cname : String =
	if self.useQualifiedName then
		'"' + self.qName + '"'
	else
		if self.name.isKeyword then
			'"' + self.name + '"'
		else
			self.name
		endif
	endif;

helper context ECORE!ENamedElement def : rulename : String =
	if self.useQualifiedRuleName then
		'"' + self.qName + '"'
	else
		if self.name.isKeyword then
			'"' + self.name + '"'
		else
			self.name
		endif
	endif;

helper context ECORE!EClass def : toRuleString() : String =
	if not self."abstract" and self.inclusionCondition then
		'rule ' + self.rulename + ' {\n' +
		'    from s : INMODEL!' + self.cname + self.inputConstraint() + '\n' +
		'    to t : OUTMODEL!' + self.cname + ' (' +
		self.contentsToString() + ')\n' +
		'}\n\n'
	else
		''
	endif;

helper context ECORE!EClass def : inputConstraint() : String =
	if self.useInElementsHelper then
		let inElementCondition : String =
			if self.useIsInElementHelper then 's.isInElement'
			else 'thisModule.inElements->includes(s)' endif
		in
		if self.hasConcreteSubclasses then
			' (\n' + 
			'		if s.oclIsTypeOf(INMODEL!' + self.cname + ') then\n' +
			'			' + inElementCondition + '\n' +
			'		else false endif)'
		else
			' (' + inElementCondition + ')'
		endif
	else
		if self.hasConcreteSubclasses then
			' in IN (s.oclIsTypeOf(INMODEL!' + self.cname + '))'
		else
			' in IN'
		endif
	endif;

helper context ECORE!EClass def : hasConcreteSubclasses : Boolean =
	not ECORE!EClass.allInstances()->select(e|
		e.eSuperTypes->includes(self) and not e."abstract")->isEmpty();

helper context ECORE!EClass def : contentsToString() : String =
	self.referencesToString(self.attributesToString(
		if self.copyXmiID then '\n' + '__xmiID__'.toAssignString() else '' endif));

helper context ECORE!EClass def : attributesToString(head : String) : String =
	self.featuresToString(head, self.eAllAttributes->select(a|a.assignable));

helper context ECORE!EClass def : referencesToString(head : String) : String =
	self.featuresToString(head, self.eAllReferences->select(r|r.assignable));

helper context ECORE!EClass def : featuresToString(head : String, feature : Sequence(ECORE!EStructuralFeature)) : String =
	feature->iterate(e; acc : String = head |
		if acc.size() = 0 then
			'\n' + e.name.toAssignString()
		else
			acc + ',\n' + e.name.toAssignString()
		endif);

helper context String def : toAssignString() : String =
	if self.isKeyword then
		'        "' + self + '" <- s."' + self + '"'
	else
		'        ' + self + ' <- s.' + self
	endif;

helper context String def : isKeyword : Boolean =
	Set{'module', 'create', 'from', 'rule', 'to', 'using', 'helper', 'context',
		'def', 'and', 'or', 'not', 'if', 'then', 'else', 'endif', 'query',
		'library', 'mapsTo', 'String', 'Boolean', 'Integer', 'Real', 'Bag',
		'Set', 'OrderedSet', 'Sequence', 'abstract', 'derived', 'refining',
		'foreach', 'distinct', 'in', 'do', 'uses', 'let', 'TupleType',
		'entrypoint', 'endpoint', 'lazy', 'extends', 'implies'}->includes(self);
