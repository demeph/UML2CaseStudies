-- @atlcompiler atl2006
-- $Id: EModelCopyGenerator.atl 7948 2010-01-31 11:48:43Z dwagelaa $
-- Generates an ATL transformation that copies models using the given Ecore meta-model
query EModelMergeGenerator = ECORE!EClass.allInstancesFrom('IN')->iterate(e; acc : String = 
	'-- @atlcompiler atl2006\n' +
	'-- Generated by: $Id: EModelCopyGenerator.atl 7948 2010-01-31 11:48:43Z dwagelaa $\n' +
	'module EModelMerge;\n\n' +
	'create OUT : OUTMODEL from IN : INMODEL, MERGE : INMODEL;\n\n' +
	'helper def : inElements : Set(INMODEL!"ecore::EObject") = INMODEL!"ecore::EObject".allInstancesFrom(\'IN\');\n\n' +
	'helper def : mergeElements : Set(INMODEL!"ecore::EObject") = INMODEL!"ecore::EObject".allInstancesFrom(\'MERGE\');\n\n' +
	'helper context OclAny def : isInElement : Boolean =\n' +
	'	thisModule.inElements->includes(self);\n\n' +
	'helper context OclAny def : isMergeElement : Boolean =\n' +
	'	thisModule.mergeElements->includes(self);\n\n'|
	acc + e.toRuleString()).
	writeTo('EModelMerge.atl'.path);

uses "lib::Config";
uses "lib::Strings";

helper context ECORE!EReference def : assignable : Boolean =
	not (self."derived" or self.container)
	and self.changeable;

helper context ECORE!EAttribute def : assignable : Boolean =
	not (self."derived") and self.changeable;

helper context ECORE!ENamedElement def : qName : String =
	self.name;

helper context ECORE!EClassifier def : qName : String =
	if self.ePackage.oclIsUndefined() then
		self.name
	else
		self.ePackage.qName + '::' + self.name
	endif;

helper context ECORE!EPackage def : qName : String =
	if self.eSuperPackage.oclIsUndefined() then
		self.name
	else
		self.eSuperPackage.qName + '::' + self.name
	endif;

helper context ECORE!ENamedElement def : cname : String =
	if self.useQualifiedName then
		'"' + self.qName + '"'
	else
		if self.name.isKeyword then
			'"' + self.name + '"'
		else
			self.name
		endif
	endif;

helper context ECORE!ENamedElement def : rulename : String =
	if self.useQualifiedRuleName then
		'"' + self.qName + '"'
	else
		if self.name.isKeyword then
			'"' + self.name + '"'
		else
			self.name
		endif
	endif;

helper context ECORE!EClass def : toRuleString() : String =
	if not self."abstract" and self.inclusionCondition then
		'rule ' + self.rulename + ' {\n' +
		'    from s : INMODEL!' + self.cname + ',\n' +
		'         m : INMODEL!' + self.cname + ' (' + self.inputConstraint('in') + ' and ' + self.inputConstraint('merge') + ')\n' +
		'    to t : OUTMODEL!' + self.cname + ' (' +
		self.contentsToString() + ')\n' +
		'}\n\n'
	else
		''
	endif;

helper context ECORE!EClass def : inputConstraint(model : String) : String =
	let inElementCondition : String =
		if self.useIsInElementHelper then 's.is' + model.firstToUpper + 'Element'
		else 'thisModule.' + model + 'Elements->includes(s)' endif
	in
	if self.hasConcreteSubclasses then
		'\n' + 
		'		if s.oclIsTypeOf(INMODEL!' + self.cname + ') then\n' +
		'			' + inElementCondition + '\n' +
		'		else false endif'
	else
		'\n' + 
		'       ' + inElementCondition
	endif;

helper context ECORE!EClass def : hasConcreteSubclasses : Boolean =
	not ECORE!EClass.allInstances()->select(e|
		e.eSuperTypes->includes(self) and not e."abstract")->isEmpty();

helper context ECORE!EClass def : contentsToString() : String =
	self.referencesToString(self.attributesToString(
		if self.copyXmiID then '\n' + '__xmiID__'.toAssignString() else '' endif));

helper context ECORE!EClass def : attributesToString(head : String) : String =
	self.featuresToString(head, self.eAllAttributes->select(a|a.assignable));

helper context ECORE!EClass def : referencesToString(head : String) : String =
	self.featuresToString(head, self.eAllReferences->select(r|r.assignable));

helper context ECORE!EClass def : featuresToString(head : String, feature : Sequence(ECORE!EStructuralFeature)) : String =
	feature->iterate(e; acc : String = head |
		if acc.size() = 0 then
			'\n' + e.name.toAssignString()
		else
			acc + ',\n' + e.name.toAssignString()
		endif);

helper context String def : toAssignString() : String =
	if self.isKeyword then
		'        "' + self + '" <- s."' + self + '"'
	else
		'        ' + self + ' <- s.' + self
	endif;

helper context String def : isKeyword : Boolean =
	Set{'module', 'create', 'from', 'rule', 'to', 'using', 'helper', 'context',
		'def', 'and', 'or', 'not', 'if', 'then', 'else', 'endif', 'query',
		'library', 'mapsTo', 'String', 'Boolean', 'Integer', 'Real', 'Bag',
		'Set', 'OrderedSet', 'Sequence', 'abstract', 'derived', 'refining',
		'foreach', 'distinct', 'in', 'do', 'uses', 'let', 'TupleType',
		'entrypoint', 'endpoint', 'lazy', 'extends'}->includes(self);
