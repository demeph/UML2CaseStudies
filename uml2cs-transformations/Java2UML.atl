-- @atlcompiler atl2006
-- $Id$
-- Merges back java method bodies into UML2 source model
module Java2UML; -- extends UML2Copy

create OUT : UML2 from IN : UML2, CODE : JAVA;

uses UML2;
uses Mappings;

-- ======================================================================
-- model-specific helpers begin
-- ======================================================================

helper def : applets : Sequence(UML2!"Applet::Applet") = UML2!"Applet::Applet".allInstances();
helper def : singletons : Sequence(UML2!"Singleton::Singleton") = UML2!"Singleton::Singleton".allInstances();
helper def : asyncs : Sequence(UML2!"Async::asynchronous") = UML2!"Async::asynchronous".allInstances();

helper context UML2!"uml::Classifier" def : isApplet : Boolean =
	thisModule.applets->exists(o|o.base_Classifier=self);

helper context UML2!"uml::Classifier" def : isSingleton : Boolean =
	thisModule.singletons->exists(o|o.base_Classifier=self);

helper context UML2!"uml::Operation" def : isAsynchronous : Boolean =
	thisModule.asyncs->exists(a|a.base_Operation=self);

helper context UML2!"uml::Classifier" def : typeDeclaration : JAVA!TypeDeclaration =
	let owner : OclAny = self.refImmediateComposite() in
	if (owner.oclIsKindOf(UML2!"uml::Classifier")) then
		owner.typeDeclaration.bodyDeclarations
			->select(b|b.oclIsKindOf(JAVA!AbstractTypeDeclaration))
			->any(t|t.name.fullyQualifiedName = self.name)
	else
		JAVA!CompilationUnit.allInstances()
			->select(c|c.package.name.fullyQualifiedName = self.getNearestPackage().qualifiedName('.'))
			->collect(c|c.types)->flatten()
			->any(t|t.name.fullyQualifiedName = self.name)
	endif;

helper context UML2!"uml::BehavioralFeature" def : javaMethodDeclaration : JAVA!MethodDeclaration =
	let t : JAVA!TypeDeclaration = self.namespace.typeDeclaration in t.bodyDeclarations
		->select(b|b.oclIsKindOf(JAVA!MethodDeclaration))
		->select(m|m.name.fullyQualifiedName = self.name)
		->select(m|
			if self.getType().oclIsUndefined() then
				if m.returnType.oclIsUndefined() then
					true
				else
					m.returnType.lexicalForm = 'void'
				endif
			else
				if m.constructor then
					t.name.lexicalForm = self.getType().name	-- constructors already have naming constraints, so this check is not strictly necessary
				else
					if m.returnType.oclIsUndefined() then
						false
					else
						if self.getType().oclIsKindOf(UML2!"uml::PrimitiveType") then
							let implTypeName : String = self.getType().name.implTypeName().regexReplaceAll('::', '.') in
							m.returnType.lexicalForm = implTypeName or
							'java.lang.' + m.returnType.lexicalForm = implTypeName
						else
							m.returnType.lexicalForm = self.getType().qualifiedName('.')
						endif
					endif
				endif
			endif)
		->any(m|thisModule.equivalentParameters(self.ownedParameter->reject(p|p.direction = #return), m.parameters));

helper def : equivalentParameters(selfpars : Sequence(UML2!"uml::Parameter"), otherpars : Sequence(JAVA!SingleVariableDeclaration)) : Boolean =
	let selfpar : UML2!"uml::Parameter" = selfpars->first() in
	let otherpar : JAVA!SingleVariableDeclaration = otherpars->first() in
	if selfpar.oclIsUndefined() then otherpar.oclIsUndefined()
	else
		if selfpar.equivalentTo(otherpar) then
			thisModule.equivalentParameters(
				selfpars->excluding(selfpar), 
				otherpars->excluding(otherpar))
		else false endif
	endif;

helper context UML2!"uml::Parameter" def : equivalentTo(v : JAVA!SingleVariableDeclaration) : Boolean =
	if v.oclIsUndefined() then
		false
	else
		if self.type.oclIsUndefined() then
			v.type.lexicalForm = 'void'
		else
			if self.type.oclIsKindOf(UML2!"uml::PrimitiveType") then
				let implTypeName : String = self.type.name.implTypeName().regexReplaceAll('::', '.') in
				v.type.lexicalForm = implTypeName or
				'java.lang.' + v.type.lexicalForm = implTypeName
			else
				v.type.lexicalForm = self.type.qualifiedName('.')
			endif
		endif
	endif;

helper context UML2!"uml::Operation" def : filteredBody() : Sequence(JAVA!Statement) =
	self.appletFilteredBody(
		self.asyncFilteredBody(
			self.javaMethodDeclaration.body.statements))
	->iterate(e; acc : String = '' |
		if acc = '' then
			acc + e.lexicalForm
		else
			acc + '\n' + e.lexicalForm
		endif);

helper context UML2!"uml::Operation" def : asyncFilteredBody(statements : Sequence(JAVA!Statement)) : Sequence(JAVA!Statement) =
	if self.isAsynchronous then
		statements->first() -- JAVA!ExpressionStatement ("new Thread() {public void run() {...}}.start();")
			.expression -- JAVA!MethodInvocation ("new Thread() {public void run() {...}}.start()")
			.expression -- JAVA!ClassInstanceCreation ("new Thread() {public void run() {...}}")
			.anonymousClassDeclaration -- JAVA!AnonymousClassDeclaration ("{public void run() {...}}")
			.bodyDeclarations.first() -- JAVA!MethodDeclaration ("public void run() {...}")
			.body -- JAVA!Block ("{...}")
			.statements -- Sequence(JAVA!Statement) ("...")
	else
		statements
	endif;

helper context UML2!"uml::Operation" def : appletFilteredBody(statements : Sequence(JAVA!Statement)) : Sequence(JAVA!Statement) =
	if self.isAppletInit then
		let fStatements : Sequence(JAVA!Statement) =
			if self.class.isSingleton then
				statements->excluding(statements->first()) -- JAVA!ExpressionStatement ("instance = this;")
			else
				statements
			endif
		in
			if self.class.isJavaAppletApplet.debug(self.class.toString() + '.isJavaAppletApplet') then
				fStatements->excluding(fStatements->first()) -- JAVA!ExpressionStatement ("setLayout(new java.awt.BorderLayout());")
			else
				fStatements
			endif
	else
		statements
	endif;

helper context UML2!"uml::Operation" def : isAppletInit : Boolean = 
	if (self.name = 'init') then
		self.class.isApplet
	else false endif;

helper context UML2!"uml::Classifier" def : isJavaAppletApplet : Boolean =
	self.typeDeclaration.superclassType.name.fullyQualifiedName = 'java.applet.Applet';
--	self.allParents().debug('allParents')->exists(p|p.umlQualifiedName = 'java::applet::Applet');

-- ======================================================================
-- model-specific helpers end
-- ======================================================================

-- ======================================================================
-- transformation rules begin
-- ======================================================================

rule OpaqueBehavior {
    from s : UML2!"uml::OpaqueBehavior" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(UML2!"uml::OpaqueBehavior") and
			if s.language.includes('java') and not s.specification.oclIsUndefined() then
				s.specification.javaMethodDeclaration.oclIsUndefined()
			else true endif
		else false endif)
    to t : UML2!"uml::OpaqueBehavior" (
        __xmiID__ <- s.__xmiID__,
		name <- s.name.debug('OpaqueBehavior'),
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        body <- s.body,
        language <- s.language,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification)
}

rule JavaOpaqueBehavior {
    from s : UML2!"uml::OpaqueBehavior" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(UML2!"uml::OpaqueBehavior") and
			if s.language.includes('java') and not s.specification.oclIsUndefined() then
				not s.specification.javaMethodDeclaration.oclIsUndefined()
			else false endif
		else false endif)
	using { index : Integer = s.language->indexOf('java'); }
    to t : UML2!"uml::OpaqueBehavior" (
        __xmiID__ <- s.__xmiID__,
		name <- s.name.debug('JavaOpaqueBehavior'),
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        body <- s.body.excluding(s.body.at(index))->insertAt(index, s.specification.filteredBody()),
        language <- s.language,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification)
}

-- ======================================================================
-- transformation rules end
-- ======================================================================
